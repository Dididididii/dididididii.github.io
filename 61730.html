<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>2022新版前端面试题 | Ga.X个人博客</title><meta name="keywords" content="前端面试题"><meta name="author" content="Ga.x"><meta name="copyright" content="Ga.x"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端面试题浏览器面试题输入一个URL到页面过程中发生了什么（高频） 首先在浏览器中输入URL 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。 DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 建立TCP连接：解析出IP地址后，根据IP地址和默认8">
<meta property="og:type" content="article">
<meta property="og:title" content="2022新版前端面试题">
<meta property="og:url" content="https://blog.dididididdii.xyz/61730.html">
<meta property="og:site_name" content="Ga.X个人博客">
<meta property="og:description" content="前端面试题浏览器面试题输入一个URL到页面过程中发生了什么（高频） 首先在浏览器中输入URL 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。 DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 建立TCP连接：解析出IP地址后，根据IP地址和默认8">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.dididididdii.xyz/img/four.webp">
<meta property="article:published_time" content="2022-09-07T05:02:13.000Z">
<meta property="article:modified_time" content="2022-10-01T06:42:39.036Z">
<meta property="article:author" content="Ga.x">
<meta property="article:tag" content="前端面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.dididididdii.xyz/img/four.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.dididididdii.xyz/61730"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ga.x","link":"链接: ","source":"来源: Ga.X个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2022新版前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-01 14:42:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/four.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ga.X个人博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2022新版前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-07T05:02:13.000Z" title="发表于 2022-09-07 13:02:13">2022-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-01T06:42:39.036Z" title="更新于 2022-10-01 14:42:39">2022-10-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2022新版前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a><strong>前端面试题</strong></h1><h2 id="浏览器面试题"><a href="#浏览器面试题" class="headerlink" title="浏览器面试题"></a><strong>浏览器面试题</strong></h2><h3 id="输入一个URL到页面过程中发生了什么（高频）"><a href="#输入一个URL到页面过程中发生了什么（高频）" class="headerlink" title="输入一个URL到页面过程中发生了什么（高频）"></a><strong>输入一个URL到页面过程中发生了什么（高频）</strong></h3><ol>
<li>首先在浏览器中输入URL</li>
<li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</li>
<li>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</li>
<li>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</li>
<li>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</li>
<li>关闭TCP连接：通过四次挥手释放TCP连接</li>
<li>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：<ol>
<li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li>
<li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li>
<li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置</li>
<li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li>
</ol>
</li>
</ol>
<h3 id="浏览器渲染机制、重绘、重排"><a href="#浏览器渲染机制、重绘、重排" class="headerlink" title="浏览器渲染机制、重绘、重排"></a><strong>浏览器渲染机制、重绘、重排</strong></h3><p>网页生成的过程：</p>
<ul>
<li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li>
<li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li>
<li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置</li>
<li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li>
</ul>
<p><strong>重排：</strong>当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>
<p>触发条件：</p>
<ol>
<li>添加或者删除可见的DOM元素</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
</ol>
<p><strong>重绘：</strong>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p>
<p>触发条件：改变元素的color、background、box-shadow等属性</p>
<h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+ CSS"></a>HTML+ CSS</h2><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a><strong>HTML语义化</strong></h3><p>是什么: 语义化标签是一 种写 HTML 标签的方法论&#x2F;方式。</p>
<p>怎么做:实现方法是遇到标题就用 h1 到 h6,遇到段落用 p,遇到文章用 article,主要内容用 main, 边栏用 aside,导航用 nav ….. (就是找到中文对应的英文)</p>
<p>解决了什么问题:明确了 HTML 的书写规范</p>
<p>优点是:一、适合搜索引擎检索;二、 适合人类阅读,利于团队维护。</p>
<p>缺点:没有</p>
<h3 id="语义化标签有哪些"><a href="#语义化标签有哪些" class="headerlink" title="语义化标签有哪些"></a><strong>语义化标签有哪些</strong></h3><ol>
<li>header  头部</li>
<li>nav     导航栏</li>
<li>section  区块</li>
<li>main    主要区域</li>
<li>article   主要内容</li>
<li>aside    侧边栏</li>
<li>footer   底部</li>
</ol>
<h3 id="meta-x2F-viewport-标签"><a href="#meta-x2F-viewport-标签" class="headerlink" title="meta &#x2F; viewport 标签"></a><strong>meta &#x2F; viewport 标签</strong></h3><p>github+上有个仓库，叫+HEAD+的仓库：[仓库地址](<a target="_blank" rel="noopener" href="https://github.com/joshbuchea/HEAD">joshbuchea&#x2F;HEAD: A simple guide to HTML  elements (github.com)</a>)，这个仓库就把所有流行的+meta+写法都告诉我们了</p>
<p><strong>meta 标签</strong></p>
<ol>
<li>meta 标签是 HTML 语言 HEAD 区的一个辅助性标签</li>
<li>meta 标签-般用于描述 HTML 网页的属性,例如:作者、关键字、网页描述、和其它的元数据」</li>
</ol>
<p><strong>viewport</strong></p>
<ol>
<li>viewport 是用户网页的可视区域,也叫视口、视区</li>
<li>主要是用来适配移动端的，比如:不让用户在移动端对页面进行缩放</li>
</ol>
<p>我一般是拷贝淘宝网移动端的 viewport</p>
<h3 id="Canvas-和-SVG-的区别"><a href="#Canvas-和-SVG-的区别" class="headerlink" title="Canvas 和 SVG 的区别"></a><strong>Canvas 和 SVG 的区别</strong></h3><ol>
<li>Canvas 主要是用笔刷来绘制 2D 图形的。</li>
<li>SVG 主要是用标签来绘制不规则矢量图的。</li>
</ol>
<p>相同点:都是主要用来画 2D 图形的。</p>
<p>不同点: </p>
<ol>
<li>Canvas 画的是位图，SVG 画的是矢量图。</li>
<li>SVG 支持分层和事件，Canvas 不支持，但是可以用库实现。</li>
</ol>
<h3 id="H5-是什么"><a href="#H5-是什么" class="headerlink" title="H5 是什么"></a><strong>H5 是什么</strong></h3><p>H5 就是移动端页面，反正不是 HTML5。</p>
<h3 id="说说-HTML5-有哪些新特性？"><a href="#说说-HTML5-有哪些新特性？" class="headerlink" title="说说 HTML5 有哪些新特性？"></a><strong>说说 HTML5 有哪些新特性？</strong></h3><ol>
<li>语义化标签</li>
<li>增强型表单包括属性以及元素</li>
<li>新增视频<video>和音频<audio>标签</li>
<li>Canvas 图形</li>
<li>地理定位</li>
<li>拖放API</li>
<li>SVG绘图</li>
</ol>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><strong>盒模型</strong></h3><p>分为两种：W3C标准盒模型和IE怪异盒模型</p>
<p>WC3: width + height</p>
<p>IE: width + height+padding+border</p>
<h3 id="如何实现垂直居中"><a href="#如何实现垂直居中" class="headerlink" title="如何实现垂直居中"></a><strong>如何实现垂直居中</strong></h3><ol>
<li>通过 verticle-align:middle 实现 CSS 垂直居中。</li>
<li>通过 display:flex 实现 CSS 垂直居中。</li>
<li>通过伪元素:before 实现 CSS 垂直居中。</li>
<li>通过 display:table-cell 实现 CSS 垂直居中。</li>
<li>通过隐藏节点实现 CSS 垂直居中。</li>
<li>已知父元素高度通过 transform 实现 CSS 垂直居中。</li>
<li>到垂直居中的位置。</li>
<li>通过 line-height 实现 CSS 垂直居中。</li>
</ol>
<p><strong>通用办法：body 加 display：flex 居中盒子加 margin：auto</strong></p>
<h3 id="flex-怎么用，常用属性有哪些？"><a href="#flex-怎么用，常用属性有哪些？" class="headerlink" title="flex 怎么用，常用属性有哪些？"></a><strong>flex 怎么用，常用属性有哪些？</strong></h3><p><strong>使用：</strong></p>
<ol>
<li>实现 flex 布局，首先我们需要有一个使用 flex 布局的元素，称为 flex container，简称”容器”。</li>
<li>容器中每个元素称为 flex item，简称”物品”。</li>
<li>容器默认有两根轴：水平的主轴(main axis) 和 交叉轴(cross axis)。</li>
</ol>
<p><strong>常用属性：</strong></p>
<ul>
<li>flex-direction: 设置主轴的方向 （row（默认值）：主轴为水平方向，起点在左端；row-reverse：主轴为水平方向，起点在右端；column：主轴为垂直方向，起点在上沿；column-reverse：主轴为垂直方向，起点在下沿；）</li>
<li>justify-content: 设置主轴上的子元素排列方式（flex-start（默认值）：起点对齐；flex-end：终点对齐；center：居中；space-between：两端对齐，物品之间的间隔相等；space-around：每个物品两侧的间隔相等）</li>
<li>flex-wrap: 设置子元素是否换行（nowrap（默认）：不换行；wrap：换行，第一行在上方；wrap-reverse：换行，第一行在下方；）</li>
<li>align-content: 设置侧轴的子元素的排列方式（多行）（stretch（默认值）：多行占满整个交叉轴；flex-start：与交叉轴的起点对齐；flex-end：与交叉轴的终点对齐；center：与交叉轴的居中点对齐；space-between：与交叉轴两端对齐，轴线之间的间隔平均分布；space-around：每根轴线两侧的间隔都相等）</li>
<li>align-items:设置侧轴上的子元素排列方式（单行）（stretch（默认值）：物品在没有设置高度和宽度时，将会铺满整个交叉轴；flex-start：交叉轴的起点对齐；flex-end：交叉轴的终点对齐；center：交叉轴的居中点对齐；baseline: item： 的第一行文字的基线对齐）</li>
<li>flex-flow:复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li>
</ul>
<h3 id="BFC-是什么"><a href="#BFC-是什么" class="headerlink" title="BFC 是什么"></a><strong>BFC 是什么</strong></h3><p>（通过举例子回答,什么情况下会产生一个 BFC,千万不要尝试回答是什么 BFC）</p>
<p><strong>是什么：</strong></p>
<ul>
<li>块级格式化上下文</li>
</ul>
<p><strong>怎么做（触发条件）：</strong></p>
<ul>
<li>浮动元素(元索的 float 不是 none)</li>
<li>绝对定位的元素(元素的 position 为 absolute 或 fixed)</li>
<li>行内块元素 inline- block</li>
<li>overflow: hidden, overflow 的值不为 visible 的块元素，只要不是 visible 默认值</li>
<li>弹性元素(display 为 flex 或 inline-flex 元素的直接子元素)</li>
</ul>
<p><strong>解决了什么问题：</strong></p>
<ul>
<li>清除浮动(为什么不用.clearfix 呢? )</li>
<li>防止 margin 合并(两个垂直方向的 div 的 margin 是会合并的，但是其中一个 div 成 BFC,就不会合</li>
</ul>
<p>BFC 全称是“块级格式化上下文”,如果给一个 div 写上 overflow: hidden,那么这个 div 里面的浮动元素就会被它包裹起来，这就是 BFC</p>
<h3 id="content-box和border-box区别"><a href="#content-box和border-box区别" class="headerlink" title="content-box和border-box区别"></a><strong>content-box和border-box区别</strong></h3><p>content-box（默认）：宽度和高度之外绘制内边距和边框</p>
<p>border-box：宽度和高度之内绘制设定元素的边框及内边距</p>
<p>行元素、块级元素、行内块元素有哪些<br>行元素：span、input、a、b、i、img</p>
<p>块元素：div、h1~h6、hr、ul、p、li、table</p>
<p>行内块元素：img、input、td</p>
<h3 id="怎么让Chrome支持小于12px的文字"><a href="#怎么让Chrome支持小于12px的文字" class="headerlink" title="怎么让Chrome支持小于12px的文字"></a><strong>怎么让Chrome支持小于12px的文字</strong></h3><p>zoom：可以改变页面上元素的尺寸，属于真实尺寸</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.span1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        zoom: <span class="number">0.8</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.span2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>测试10px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>测试12px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>-webkit-transform:scale()只对可以定义宽高的元素生效，如果是行内元素的话，应该先转为行内块元素。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.span1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        -webkit-<span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0.8</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.span2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>测试10px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>测试12px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="css3特性"><a href="#css3特性" class="headerlink" title="css3特性"></a><strong>css3特性</strong></h3><ol>
<li>border-radius &#x2F;&#x2F; 圆角</li>
<li>text-shadow &#x2F;&#x2F; 文字阴影</li>
<li>transition &#x2F;&#x2F; 动画过度</li>
<li>animation &#x2F;&#x2F; 动画</li>
<li>box-shadow &#x2F;&#x2F; 盒子阴影</li>
<li>border-image &#x2F;&#x2F; 图片边框</li>
<li>background-clip &#x2F;&#x2F; 背景绘制</li>
<li>color: rgba(0,0,0,0.1) &#x2F;&#x2F; 透明度设置</li>
<li>flex &#x2F;&#x2F;布局</li>
<li>&#x2F;&#x2F; 媒体查询</li>
<li>&#x2F;&#x2F; 多列布局</li>
</ol>
<h3 id="iframe的优缺点有哪些"><a href="#iframe的优缺点有哪些" class="headerlink" title="iframe的优缺点有哪些"></a><strong>iframe的优缺点有哪些</strong></h3><p><strong>优点：</strong></p>
<ul>
<li>iframe能够原封不动地把嵌入的网页展示出来；</li>
<li>提高页面代码的复用性；</li>
<li>解决加载缓慢的第三方内容，如图标和广告等的加载问题；</li>
<li>在处理上传或局部刷新时，避免了页面整体刷新；</li>
<li>iframe解决部分跨域问题；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>iframe会阻塞主页面的 onload 事件；</li>
<li>无法被一些搜索引擎索引到；</li>
<li>页面会增加服务器的http请求；</li>
<li>会产生很多页面，不便于管理；</li>
<li>很多移动设备无法完全显示框架，设备兼容性差；</li>
<li>会出现区域的上下、左右滚动条，滚动条会挤占页面空间；</li>
<li>使用框架时，要保证正确的使用导航链接，容易造成链接死循环；</li>
</ul>
<h3 id="px、em、rem、vh-x2F-vw的区别"><a href="#px、em、rem、vh-x2F-vw的区别" class="headerlink" title="px、em、rem、vh&#x2F;vw的区别"></a><strong>px、em、rem、vh&#x2F;vw的区别</strong></h3><p><strong>px：</strong> 像素px是相对于显示器屏幕分辨率而言的一个单位</p>
<p><strong>rpx</strong>:是微信小程序独有的、解决屏幕自适应的尺寸单位</p>
<p><strong>em：</strong> 相对于父元素的字体尺寸<br><strong>rem：</strong> 相对于根元素<html>的字体大小<br><strong>vh\vw：</strong> 相对于视口的高度和宽度。1vh &#x3D; 1&#x2F;100 的浏览窗口高度，1vw &#x3D; 1&#x2F;100 的浏览器窗口宽度</p>
<h3 id="css选择器有哪些"><a href="#css选择器有哪些" class="headerlink" title="css选择器有哪些"></a><strong>css选择器有哪些</strong></h3><p>标签选择器、类选择器、层级选择器(后代选择器)、id选择器、组选择器、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8&spm=1001.2101.3001.7020">伪类选择器</a></p>
<p>!important &gt;内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p>
<ol>
<li>选择器越具体,优先级越高(比如: id 比 class 更高)</li>
<li>相同优先级，写在后面的，覆盖写在前面的</li>
<li>属性后面加!important 优先级最高，但是要少用</li>
</ol>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a><strong>清除浮动</strong></h3><ol>
<li>父元素使用overflow:hidden、auto</li>
<li>使用伪元素清除浮动</li>
</ol>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a><strong>伪类和伪元素</strong></h3><p><strong>a:link	&#x2F;&#x2F; 未访问</strong></p>
<p><strong>a:hover   &#x2F;&#x2F;  悬停</strong></p>
<p><strong>a:visited  &#x2F;&#x2F; 已访问</strong></p>
<p><strong>a:active   &#x2F;&#x2F; 已选择</strong></p>
<p>常用的伪元素：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;  <span class="comment">// 内容前面插入新内容</span></span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span>&#123;  <span class="comment">// 内容之后插入新内容</span></span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写一个左中右布局占满屏幕，其中左右两块是固定宽度200-，中间自适应宽"><a href="#写一个左中右布局占满屏幕，其中左右两块是固定宽度200-，中间自适应宽" class="headerlink" title="写一个左中右布局占满屏幕，其中左右两块是固定宽度200 ，中间自适应宽"></a><strong>写一个左中右布局占满屏幕，其中左右两块是固定宽度200 ，中间自适应宽</strong></h3><p>第一种：使用flex </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种：使用绝对定位</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line">      <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.left</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.center</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: burlywood;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何画一条0-5的线？"><a href="#如何画一条0-5的线？" class="headerlink" title="如何画一条0.5的线？"></a><strong>如何画一条0.5的线？</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfrom:scale(0.5)</span><br></pre></td></tr></table></figure>

<h3 id="css绘制三角形"><a href="#css绘制三角形" class="headerlink" title="css绘制三角形"></a><strong>css绘制三角形</strong></h3><p>普通三角形</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>右上角角标的三角形 </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分别写出3种垂直居中的方法"><a href="#分别写出3种垂直居中的方法" class="headerlink" title="分别写出3种垂直居中的方法"></a><strong>分别写出3种垂直居中的方法</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一种 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: bisque;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第二种 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: bisque;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第三种 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: bisque;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a><strong>JavaScript面试题</strong></h2><h3 id="从输入url到展示页面加载的过程"><a href="#从输入url到展示页面加载的过程" class="headerlink" title="从输入url到展示页面加载的过程"></a><strong>从输入url到展示页面加载的过程</strong></h3><ul>
<li>通过DNS解析获得网址的对应IP地址</li>
<li>浏览器与远程web服务器 通过TCP三次握手协商来建立一个 TCP&#x2F;IP 连接</li>
<li>浏览器 通过TCP&#x2F;IP连接 向web服务器 发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器渲染:解析HTML、解析CSS、解析JS、Render树</li>
</ul>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a><strong>三次握手和四次挥手</strong></h3><p><strong>总结</strong>：三次握手是建立连接，四次挥手是关闭连接</p>
<p><strong>握手</strong></p>
<ul>
<li>客户端发送syn数据包表示请求连接</li>
<li>服务器响应syn和ack的数据包表示同意建立连接</li>
<li>客户端再发送ack数据包表示成功连接</li>
</ul>
<p> <strong>挥手</strong></p>
<ul>
<li>客户端发送FIN表示关闭连接</li>
<li>服务端收到FIN,发送ACK,表示等待关闭</li>
<li>服务端还可以发送未发送数据，客户端还可以接收数据，等服务端发送完数据后，发送FIN进入最后确认状态</li>
<li>客户端收到数据后，发送ACK进入超时等待状态，服务端收到ACK后，立即关闭连接</li>
</ul>
<h3 id="为什么是三次握手不是两次握手？"><a href="#为什么是三次握手不是两次握手？" class="headerlink" title="为什么是三次握手不是两次握手？"></a><strong>为什么是三次握手不是两次握手？</strong></h3><p>服务端发送完syn&#x2F;ack之后就建立连接，为了防止已失效的请求报文，突然又传到服务器引起错误</p>
<h3 id="为什么js是单线程的？"><a href="#为什么js是单线程的？" class="headerlink" title="为什么js是单线程的？"></a><strong>为什么js是单线程的？</strong></h3><p><strong>单线程</strong> ：只有一个线程，只能做一件事</p>
<p>js里面有可视的DOM,如果是多线程的话，这个线程正在删除DOM节点，另一个线程在编辑DOM节点，导致浏览器不知道听谁的。</p>
<h3 id="如何实现异步编程？"><a href="#如何实现异步编程？" class="headerlink" title="如何实现异步编程？"></a><strong>如何实现异步编程？</strong></h3><p>回调函数</p>
<ul>
<li>优点：简单、容易理解</li>
<li>缺点：不利于维护、代码耦合高</li>
</ul>
<p>事件监听</p>
<ul>
<li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
<li>缺点：事件驱动型，流程不够清晰</li>
</ul>
<p>Promise 对象</p>
<ul>
<li>优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数</li>
<li>缺点：编写和理解，相对比较难</li>
</ul>
<p>async 函数</p>
<ul>
<li>优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰</li>
<li>缺点：错误处理机制</li>
</ul>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a><strong>宏任务和微任务</strong></h3><p>宏任务：script(整体代码)、setTimeout、setInterval、setlmmediate、l&#x2F;O&#x2F;UI rendering</p>
<p>微任务：promise、Object.observe、MutationObserver</p>
<p>优先级：process.nextTick &gt; promise.then&gt;setTimeout&gt;setlmmediate</p>
<h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a><strong>回流和重绘</strong></h3><p><strong>回流</strong>：当render tree中的元素结构或尺寸发生改变，浏览器重新渲染的过程叫做回流</p>
<p>比如：</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小变化</li>
<li>内容变换</li>
<li>添加或删除节点</li>
<li>激活css伪类</li>
</ul>
<p><strong>重绘：</strong>当页面元素的样式发生改变，不影响文档流中的位置，这个过程叫做重绘</p>
<p><strong>总结</strong>：回流一定会引起重绘，重绘不一定会引起回流</p>
<h3 id="网页中有大量的图片加载很慢"><a href="#网页中有大量的图片加载很慢" class="headerlink" title="网页中有大量的图片加载很慢"></a><strong>网页中有大量的图片加载很慢</strong></h3><ul>
<li>图片<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%87%92%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">懒加载</a>，滚动到某个位置再加载图片</li>
<li>图片预加载，预先加载图片的前一张和后一张</li>
</ul>
<h3 id="DOM和BOM"><a href="#DOM和BOM" class="headerlink" title="DOM和BOM"></a><strong>DOM和BOM</strong></h3><p>**DOM:**document,获取元素得文档对象类型，可以设置标签的属性,跟浏览器没有关系 </p>
<p>**BOM:**browser object model,浏览器对象模型，提供浏览器窗口进行交互的对象，管理页面与页面之间的通讯，核心对象是window</p>
<p><strong>常用有：</strong>location(url相关的操作)、history(历史相关的操作)、navigator(浏览器相关的信息)</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><strong>事件冒泡</strong></h3><p>一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段：</p>
<ul>
<li>捕获阶段（从window对象传导到目标节点（从外到里），这个阶段不会响应任何事件）</li>
<li>目标阶段，（在目标节点上触发）</li>
<li>冒泡阶段（从目标节点传导回window对象（从里到外）），事件委托&#x2F;事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层</li>
</ul>
<h3 id="普通函数和构造函数的区别"><a href="#普通函数和构造函数的区别" class="headerlink" title="普通函数和构造函数的区别"></a><strong>普通函数和构造函数的区别</strong></h3><ol>
<li>构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写</li>
<li>调用方式不一样，普通函数直接调用，构造函数要用关键字new来调用</li>
<li>调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象</li>
<li>构造函数内部的this指向实例，普通函数内部的this指向调用函数的对象（如果没有对象调用，默认为window）</li>
<li>构造函数默认的返回值是创建的对象（也就是实例），普通函数的返回值由return语句决定</li>
<li>构造函数的函数名与类名相同</li>
</ol>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a><strong>内存泄露</strong></h3><p>内存泄漏是指一块被分配的内存既不能使用又不能回收，直到浏览器进程结束</p>
<h3 id="JS垃圾回收机制是怎样的？"><a href="#JS垃圾回收机制是怎样的？" class="headerlink" title="JS垃圾回收机制是怎样的？"></a><strong>JS垃圾回收机制是怎样的？</strong></h3><p>垃圾回收机制是为了防止内存泄漏，寻找没用的变量，释放它所指向的内存</p>
<h3 id="JS垃圾回收方式"><a href="#JS垃圾回收方式" class="headerlink" title="JS垃圾回收方式"></a><strong>JS垃圾回收方式</strong></h3><p><strong>有两种方式：</strong> 标记清除、引用计数</p>
<p><strong>标记清除</strong>：大部分浏览器使用这个方法，当变量进入执行环境时，垃圾回收器将该变量进行了标记，当该变量离开环境的时候，再度标记，进行删除。</p>
<p><strong>引用计数</strong>：这种方式常常会引起内存泄露，主要存在于低版本浏览器。跟踪某一个变量的使用次数，当变量赋值给另一个变量的时，引用次数加；如果该变量又赋值另一个变量，引用次数减1，当引用次数为0时，进行删除。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a><strong>事件委托</strong></h3><p>事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p>
<h3 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a><strong>什么是浏览器缓存？</strong></h3><p>浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。缓存会根据进来的请求保存输入内容的副本。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。</p>
<h3 id="使用缓存的原因"><a href="#使用缓存的原因" class="headerlink" title="使用缓存的原因"></a><strong>使用缓存的原因</strong></h3><ol>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟</li>
</ol>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h3><p><strong>概念</strong>：面向对象是一种编程思想</p>
<p><strong>特点</strong>：</p>
<ol>
<li>封装，属性和方法定义在对象里面。</li>
<li>继承，子对象可以使用父对象的属性和方法</li>
<li>多态，分别有两种形式。</li>
</ol>
<p><strong>重载</strong>：同一方法名，根据传入的参数不同，而执行不同操作</p>
<p><strong>重写</strong>：子对象重新定义一个新的属性或方法覆盖父对象中继承的属性或方法。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><p>基础数据类型：Undefined、Null、Boolean、Number、String、Symbol【ES6】、Bigint【ES10】</p>
<p>复杂数据类型（三大引用类型）：Object、Array、Function 【Arrar和Function都属于Object类型】</p>
<h3 id="变量和函数声明的提升"><a href="#变量和函数声明的提升" class="headerlink" title="变量和函数声明的提升"></a><strong>变量和函数声明的提升</strong></h3><ul>
<li>在js中声明变量和函数会提升到最顶部执行</li>
<li>函数的提升高于变量的提升</li>
<li>匿名函数不会提升。</li>
</ul>
<h3 id="数组常用的方法"><a href="#数组常用的方法" class="headerlink" title="数组常用的方法"></a><strong>数组常用的方法</strong></h3><p>arr.push() 从后面添加元素，返回值为添加完后的数组的长度</p>
<p>arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素</p>
<p>arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素</p>
<p>arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度</p>
<p>arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素</p>
<p>str.split() 将字符串转化为数组</p>
<p> arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的</p>
<p>arr.reverse() 将数组反转,返回值是反转后的数组</p>
<p> arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</p>
<p> arr.forEach() 遍历数组,无return  即使有return，也不会返回任何值，并且会影响原来的数组</p>
<p> arr.map() 映射数组(遍历数组),有return 返回一个新数组 。</p>
<p> arr.filter() 过滤数组，返回一个满足要求的数组 </p>
<h3 id="判断数据是NaN"><a href="#判断数据是NaN" class="headerlink" title="判断数据是NaN"></a><strong>判断数据是NaN</strong></h3><p>isNaN()；</p>
<p>注意：isNaN(undefined)也是return true，所以，外层要先判断不是undefined</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">NaN</span></span><br><span class="line"><span class="keyword">if</span>(a !== <span class="literal">undefined</span> )&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a><strong>$nextTick</strong></h3><p>更新完data数据后，需要及时渲染视图层</p>
<h3 id="new-做了什么"><a href="#new-做了什么" class="headerlink" title="new 做了什么"></a><strong>new 做了什么</strong></h3><p>推理：</p>
<ol>
<li>创建临时对象新对象</li>
<li>绑定原型</li>
<li>指定 this &#x3D;临时对象</li>
<li>执行构造函数</li>
<li>返回临时对象</li>
</ol>
<h3 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a><strong>谈谈this对象的理解</strong></h3><p>直接输入this指向window（全局）</p>
<ul>
<li>在非严格模式下，this指向window</li>
<li>在严格模式下，this指向undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);   <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun1</span>()</span><br></pre></td></tr></table></figure>

<p>作为方法被调用，谁调用方法，this就指向谁</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>测试10px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> span = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.span1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  span.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//输出：&lt;span class=&quot;span1&quot;&gt;测试10px&lt;/span&gt;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>元素绑定事件，this指向DOM对象 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>测试10px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> span = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.span1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  span.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//输出：&lt;span class=&quot;span1&quot;&gt;测试10px&lt;/span&gt;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造函数</p>
<ul>
<li>构造函数：名称规范用大驼峰模式</li>
<li>new关键字做了什么？<ol>
<li>创建了一个空对象</li>
<li>将空对象的原型，指向构造函数的原型</li>
<li>this指向空对象</li>
<li>如果构造函数返回一个基本类型的值 则返回结果<strong>没有变化</strong></li>
<li>如果返回一个对象 则结果就是<strong>你返回的对象</strong></li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数：名称规范用大驼峰模式</span></span><br><span class="line"><span class="comment">// new关键字做了什么？</span></span><br><span class="line"><span class="comment">// new会创建对象，将构造函数(Dog)的this指向创建出来的对象---&gt;dog</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lxy&quot;</span>,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fun</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//dog</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">fun</span>()</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> == dog.<span class="property">__proto__</span>);  <span class="comment">//将空对象的原型，指向构造函数的原型</span></span><br></pre></td></tr></table></figure>

<p>箭头函数，this指向它的父级</p>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a><strong>防抖和节流</strong></h3><p>**函数防抖(debounce)**：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</p>
<p>实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法</p>
<p>函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</p>
<p>防抖使用场景：</p>
<p>王者荣耀回城补状态，过程需要10秒，中途被人打断或者回城出来再次回城，还是需要10秒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">          timer= <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;防抖&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">      btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">debounce</span>(handle, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<p> 函数节流(throttle)：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。 </p>
<p> 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return</p>
<p> 节流使用场景：</p>
<p> 金身90s cd 在这90秒内是无法使用的 但是过了90s 又可以再次使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">          canRun = <span class="literal">false</span>;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            canRun = <span class="literal">true</span>;</span><br><span class="line">          &#125;, time);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;节流&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">      btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="title function_">throttle</span>(sayHi, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<p><strong>Map 跟 foreach 区别</strong></p>
<p>forEach() 方法不会返回执行结果，而是undefined。</p>
<p>也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。</p>
<p>.forEach() 可以做到的东西，map() 也同样可以。反过来也是如此。</p>
<p>.map() 会分配内存空间存储新数组并返回，forEach() 不会返回数据。</p>
<p>.forEach() 允许callback更改原始数组的元素。map() 返回新的数组。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h3><ol>
<li>减少http请求</li>
<li>减少DOM的操作</li>
<li>使用浏览器缓存</li>
<li>压缩css和js文件</li>
<li>css放在页面的最上面，js放在页面的最下面</li>
<li>使用CDN</li>
<li>避免重定向</li>
<li>避免图片 src 为空</li>
</ol>
<h3 id="‘-x3D-x3D-’跟’-x3D-x3D-x3D-’的区别"><a href="#‘-x3D-x3D-’跟’-x3D-x3D-x3D-’的区别" class="headerlink" title="‘&#x3D;&#x3D;’跟’&#x3D;&#x3D;&#x3D;’的区别"></a><strong>‘&#x3D;&#x3D;’跟’&#x3D;&#x3D;&#x3D;’的区别</strong></h3><p>‘&#x3D;&#x3D;’值相等即可（判断之前会做类型转换）</p>
<p>‘&#x3D;&#x3D;&#x3D;’类型和值都要相等</p>
<h3 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var let const的区别"></a><strong>var let const的区别</strong></h3><p>var变量提升</p>
<p>let,const都是局部变量</p>
<p>const只能赋值一次，不能重新赋值，声明必须赋值</p>
<p>同一作用域下let和const不能声明同名变量，而var可以</p>
<h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a><strong>undefined和null</strong></h3><p>undefined：</p>
<ol>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ol>
<p>undefined 转化为数字类型为NaN（Not-a-Number 非数字值）</p>
<p>而null转化为数字类型，结果为0</p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a><strong>箭头函数和普通函数的区别</strong></h3><p>箭头函数</p>
<ol>
<li>匿名函数，this指向的是父级,也就是谁创建它，this就指向谁</li>
<li>不能进行函数提升</li>
<li>不能new</li>
<li>不能改变this指向</li>
</ol>
<p>普通函数this，谁调用，this就指向谁</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a><strong>作用域和作用域链</strong></h3><ul>
<li>作用域就是代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存</li>
<li>当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条)</li>
<li>内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数</li>
<li>当在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，直到全局作用域。</li>
</ul>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a><strong>原型与原型链</strong></h3><p><strong>谈谈你对原型的理解？</strong></p>
<p>每当定义一个对象（函数也是对象），对象中都会有一些预定义属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是，所有对象实例共享它的属性和方法</p>
<p><strong>什么是原型链？原型链解决的是什么问题？</strong></p>
<ol>
<li>原型链解决的主要是继承问题</li>
<li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li>
</ol>
<p><strong>prototype 和 *<em>proto*</em> 区别是什么</strong>？</p>
<ol>
<li>prototype是构造函数的属性</li>
<li><code>__proto__</code>是每个实例都有的属性，可以访问 [[prototype]] 属性</li>
<li>实例的<code>__proto__</code>与其构造函数的prototype指向的是同一个对象</li>
</ol>
<h3 id="cookies-sessionStorage和localstorage区别"><a href="#cookies-sessionStorage和localstorage区别" class="headerlink" title="cookies sessionStorage和localstorage区别"></a><strong>cookies sessionStorage和localstorage区别</strong></h3><p>存储大小：Cookies不能超过4k, sessionStorage、localstorage，可以达到5m甚 至更大</p>
<p>存储时间：</p>
<ul>
<li>cookies设置有效时间</li>
<li>sessionStorage浏览器关闭，自动清除</li>
<li>localstorage除非删除，否则一直存在</li>
</ul>
<h3 id="apply-bind-call的区别"><a href="#apply-bind-call的区别" class="headerlink" title="apply,bind,call的区别"></a><strong>apply,bind,call的区别</strong></h3><p>传参方式不同</p>
<ul>
<li>apply(obj,[1,2]) &#x2F;&#x2F;以数组方式</li>
<li>bind(obj,1,2)() &#x2F;&#x2F;以逗号隔开，返回函数</li>
<li>call(obj,1,2) &#x2F;&#x2F;以逗号隔开</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><p><strong>概念：</strong>函数嵌套函数</p>
<p><strong>作用：</strong></p>
<ol>
<li>内部函数可以访问外部函数的参数和变量</li>
<li>变量保存在内存中</li>
</ol>
<p><strong>缺点：</strong>使用不当，会导致内存泄漏</p>
<p><strong>解决：</strong>在退出函数之前，将不适用的变量全部删除</p>
<h3 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a><strong>typeof和instanceof的区别</strong></h3><p>同：判断一个变量是否为空， 或者是什么类型的</p>
<p>异：</p>
<ol>
<li>typeof返回值是一个字符串, number, boolean, string, function, object, undefined</li>
<li>typeof缺点：null的值object,无法分辨是null还是object</li>
<li>instanceof：只能识别object，function，Array</li>
</ol>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a><strong>ES6新特性</strong></h3><ol>
<li>变量声明</li>
<li>解构赋值</li>
<li>模板字符串（template string）</li>
<li>ES6 提供了新的语法规则来定义函数 —— 箭头函数</li>
<li>数据结构Set</li>
<li>数据结构 Map</li>
<li>for…of 循环</li>
<li>Promise对象</li>
<li>async&#x2F;await</li>
</ol>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><strong>数组去重</strong></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">arr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr1.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    arr1.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">21</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item,index,arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数组对象去重"><a href="#数组对象去重" class="headerlink" title="数组对象去重"></a><strong>数组对象去重</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;林青霞&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三丰&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;段誉&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">preValue, item</span>) &#123;</span><br><span class="line">  obj[item.<span class="property">key</span>] ? <span class="string">&quot;&quot;</span> : (obj[item.<span class="property">key</span>] = <span class="literal">true</span> &amp;&amp; preValue.<span class="title function_">push</span>(item));</span><br><span class="line">  <span class="keyword">return</span> preValue;</span><br><span class="line">&#125;, []); </span><br></pre></td></tr></table></figure>

<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a><strong>同步和异步</strong></h3><p>同步： 只有前一个任务执行完毕，才能执行下一个任务</p>
<p>异步：不会阻塞下面代码执行，前一个任务还没执行完毕，下一个任务依然执行</p>
<p>比如：定时器（setTimeout、setInterval） 、ajax的异步请求、promise</p>
<h3 id="深拷贝和浅拷贝的方法"><a href="#深拷贝和浅拷贝的方法" class="headerlink" title="深拷贝和浅拷贝的方法"></a><strong>深拷贝和浅拷贝的方法</strong></h3><ul>
<li>浅拷贝：如果原地址改变，那么拷贝的对象也会改变，新旧对象共享内存，修改其中一个，另一个也会影响</li>
<li>深拷贝：内存中开辟一块新的地址存放赋值的对象，新旧对象不会共享内存，修改其中一个，不会影响另一个</li>
</ul>
<p><strong>浅拷贝：</strong></p>
<ol>
<li>Object.assign</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>扩展运算符(…)</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;...obj1&#125;;</span><br></pre></td></tr></table></figure>

<p> <strong>深拷贝</strong></p>
<ol>
<li>JSON对象来实现深拷贝【缺点：函数无法拷贝，会显示undefined】</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(str))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>递归</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="number">015</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj=== <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">                    objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobby</span>:&#123;</span><br><span class="line">        <span class="attr">motion</span>: <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2);</span><br></pre></td></tr></table></figure>



<h2 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h2><h3 id="MVC和MVVM"><a href="#MVC和MVVM" class="headerlink" title="MVC和MVVM"></a><strong>MVC和MVVM</strong></h3><p><strong>MVC:</strong></p>
<p>Model:数据层（data）,负责保存应用数据，与后端数据进行同步</p>
<p>View:视图层，负责视图展示，将Model的数据渲染出来</p>
<p>Controller:控制器，负责业务逻辑，根据用户行为对Model数据进行修改</p>
<p>缺点：前后端不分离，数据流混乱</p>
<p><strong>MVVM:</strong></p>
<p>Model:数据层</p>
<p>View:视图层</p>
<p>ViewModel:数据模型，视图和数据之间的转换</p>
<p>优点：</p>
<ol>
<li>结构分离，view和model可以相互独立</li>
<li>双向绑定</li>
<li>前后端分离</li>
</ol>
<h3 id="虚拟DOM和真实DOM"><a href="#虚拟DOM和真实DOM" class="headerlink" title="虚拟DOM和真实DOM"></a><strong>虚拟DOM和真实DOM</strong></h3><ul>
<li>虚拟dom是object类型的对象</li>
<li>虚拟dom属性比较少，真实dom属性比较多，因为虚拟dom是内部使用，不需要真实dom那么多属性</li>
<li>虚拟dom最终转成真实dom渲染在页面</li>
</ul>
<h3 id="vue全家桶"><a href="#vue全家桶" class="headerlink" title="vue全家桶"></a><strong>vue全家桶</strong></h3><p>vue-cli、vuex、vue-router、axios</p>
<h3 id="做过哪些Vue的性能优化？"><a href="#做过哪些Vue的性能优化？" class="headerlink" title="做过哪些Vue的性能优化？"></a><strong>做过哪些Vue的性能优化？</strong></h3><ul>
<li>v-if和v-for不能连用</li>
<li>key保证唯一</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表动态加载</li>
<li>图片懒加载</li>
</ul>
<h3 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a><strong>Vue的优点</strong></h3><ul>
<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>
<li>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</li>
<li>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>结构分离，view和model可以相互独立，使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</li>
<li>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势。</li>
</ul>
<h3 id="vue的自定义指令"><a href="#vue的自定义指令" class="headerlink" title="vue的自定义指令"></a><strong>vue的自定义指令</strong></h3><p>概念：自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用</p>
<p>添加自定义指令的两种方式：</p>
<ul>
<li>全局指令： 通过 Vue.directive() 函数注册一个全局的指令。</li>
<li>局部指令：通过组件的 directives 属性，对该组件添加一个局部的指令。</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p>创建前后—挂载前后—更新前后—销毁前后</p>
<ol>
<li>beforeCreate：在实例部分（事件&#x2F;⽣命周期）初始化完成之后调⽤。</li>
<li>created：在完成外部的注⼊&#x2F;双向的绑定等的初始化之后调⽤。</li>
<li>beforeMount：在页⾯渲染之前执⾏。</li>
<li>mounted：dom 元素在挂载到页⾯之后执⾏。</li>
<li>beforeUpdate：数据改变，还没重新渲染之前执⾏。</li>
<li>updated：渲染数据完成之后执⾏。</li>
<li>执⾏销毁需要调⽤：vm.$destroy()</li>
<li>beforeDestroy：实例销毁之前执⾏。</li>
<li>destroyed：实例销毁之后执⾏。</li>
</ol>
<p><strong>组件生命周期：</strong></p>
<ol>
<li>actived:创建</li>
<li>deactived:销毁</li>
</ol>
<h3 id="vue中父子组件的生命周期"><a href="#vue中父子组件的生命周期" class="headerlink" title="vue中父子组件的生命周期"></a><strong>vue中父子组件的生命周期</strong></h3><p><strong>渲染的过程</strong></p>
<ul>
<li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
</ul>
<p><strong>子组件更新过程</strong></p>
<ul>
<li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
</ul>
<p><strong>父组件更新过程</strong></p>
<ul>
<li>父beforeUpdate-&gt;父updated</li>
</ul>
<p><strong>销毁过程</strong></p>
<ul>
<li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ul>
<h3 id="v-if和v-for为什么不能同时使用？"><a href="#v-if和v-for为什么不能同时使用？" class="headerlink" title="v-if和v-for为什么不能同时使用？"></a><strong>v-if和v-for为什么不能同时使用？</strong></h3><p><strong>Vue2</strong>：v-for的优先级是高于v-if的，如果作用在同一元素上，输出的渲染函数中可以看除会先执行循环再判断条件，哪怕只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会造成性能的浪费。</p>
<p><strong>Vue3</strong>：v-if的优先级时高于v-for的，因此v-if执行时要调用的变量可能还不存在，会导致报错。</p>
<h3 id="Vue兄弟组件通信"><a href="#Vue兄弟组件通信" class="headerlink" title="Vue兄弟组件通信"></a><strong>Vue兄弟组件通信</strong></h3><p>方法1：</p>
<p>通过父组件媒介，从组件1传给父组件，再从父组件传给组件2</p>
<p>方法2：</p>
<p>组件1</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&quot;name&quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>组件2</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&quot;name&quot;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="Vue-中-keep-alive-的作用是什么？"><a href="#Vue-中-keep-alive-的作用是什么？" class="headerlink" title="Vue 中 keep-alive 的作用是什么？"></a><strong>Vue 中 keep-alive 的作用是什么？</strong></h3><p>组件缓存，用于那些频繁切换的页面，减少因页面频繁切换导致页面频繁的创建和销毁等损耗性能的情况。里面有两个生命周期钩子，创建actived和销毁deactived，你可以在这两个钩子里面做一些事情。</p>
<h3 id="vue2-0和vue3-0区别"><a href="#vue2-0和vue3-0区别" class="headerlink" title="vue2.0和vue3.0区别?"></a><strong>vue2.0和vue3.0区别?</strong></h3><p><strong>更小：</strong>vue2对象编程，vue3是函数式编程，更利于代码的压缩，返回值类型校验</p>
<p><strong>更快：</strong>vue3修改了虚拟dom的算法;</p>
<p><strong>api一致性：</strong>vue3最开始的版本可以完美兼容vue2的api；</p>
<p><strong>数据双向绑定：</strong>vue2 采用了defineProperty，而vue3则采用了proxy;</p>
<p><strong>开放更多底层功能：</strong>比如render、依赖收集功能，可以更好的进行自定义化开发，可以写更多的高阶组件</p>
<h3 id="Vue-中-V-bind-和-V-model-有什么区别？"><a href="#Vue-中-V-bind-和-V-model-有什么区别？" class="headerlink" title="Vue 中 V-bind 和 V-model 有什么区别？"></a><strong>Vue 中 V-bind 和 V-model 有什么区别？</strong></h3><p>v-model是动态双向绑定，view层和model层相互关联，一方变化则会影响另一方，基本上用在表单元素上；v-bind是数据绑定，没有双向绑定的效果，任何有效元素上都可以使用</p>
<h3 id="Vue-生命周期中-created-和-mounted-有什么区别？"><a href="#Vue-生命周期中-created-和-mounted-有什么区别？" class="headerlink" title="Vue 生命周期中 created 和 mounted 有什么区别？"></a><strong>Vue 生命周期中 created 和 mounted 有什么区别？</strong></h3><p><strong>created：</strong>HTML没有渲染出来，不能直接操作dom节点；</p>
<p><strong>mounted：</strong>HTML已渲染，可以直接操作dom节点。</p>
<h3 id="Vue路由有哪些模式"><a href="#Vue路由有哪些模式" class="headerlink" title="Vue路由有哪些模式"></a><strong>Vue路由有哪些模式</strong></h3><p><strong>hash:</strong></p>
<ol>
<li>hash 模式的路由中带有 # 号</li>
<li>hash 模式可以兼容部分低版本的浏览器</li>
<li>路由前端自己控制</li>
</ol>
<p><strong>history:</strong></p>
<ol>
<li>history 模式是使用正常的 url 路径显示</li>
<li>history 模式因为是使用的 HTML5 的新规范，所以不能兼容低版本的浏览器</li>
<li>打包之后，刷新，会出现404情况，需要后台配置</li>
</ol>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a><strong>插槽</strong></h3><p>插槽就是子组件中的提供给父组件使用的一个占位符，用<slot></slot> 表示，父组件可以在这个占位符中填充任何模板代码</p>
<p>插槽分别有三种：具名插槽、匿名插槽、作用域插槽</p>
<p>具名插槽：子组件在slot插槽name属性自定义名称，父组件通过slot属性填充插槽的位置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">//父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是header部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用域插槽：子组件的属性通过slot插槽传给父组件使用</p>
<p>子组件：把user对象通过slot插槽传给父组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">user</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;lxy&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>父组件：模板字符串template中v-slot指定接收</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="attr">slot</span>:<span class="keyword">default</span>=<span class="string">&quot;&#123;user&#125;&quot;</span>&gt;</span><br><span class="line">   &#123;&#123;user&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a><strong>vue双向绑定</strong></h3><p>vue中采用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=mvvm&spm=1001.2101.3001.7020">mvvm</a>的模式，view层与model层两者进行关联，任何一方的变化都会让另外一方受到影响</p>
<h3 id="vue双向绑定的原理"><a href="#vue双向绑定的原理" class="headerlink" title="vue双向绑定的原理"></a><strong>vue双向绑定的原理</strong></h3><p>vue中内部采用了发布-订阅模式。内部结合了Object.defineProperty这个ES5的新特性，对vue传入的数据进行了相应的数据拦截，为其动态添加get与set方法。当数据变化的时候，就会触发对应的set方法，当set方法触发完成的时候，内部会进一步触发watcher,当数据改变了，接着进行虚拟dom对比，执行render,后续视图更新操作完毕</p>
<h3 id="Vue中key的作用是什么"><a href="#Vue中key的作用是什么" class="headerlink" title="Vue中key的作用是什么"></a><strong>Vue中key的作用是什么</strong></h3><p>key是v-for渲染列表时的节点标识，当列表发生变化，Vue就会基于key的值重新排列元素顺序，并移除key不存在的元素，提升运行效率</p>
<h3 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="headerlink" title="常用的事件修饰符"></a><strong>常用的事件修饰符</strong></h3><ul>
<li>.stop 阻止事件冒泡</li>
<li>.self 仅绑定元素自身可触发</li>
<li>.prevent 阻止默认行为</li>
<li>.once 只触发一次</li>
</ul>
<h3 id="Vue常用的指令有哪些"><a href="#Vue常用的指令有哪些" class="headerlink" title="Vue常用的指令有哪些"></a><strong>Vue常用的指令有哪些</strong></h3><ul>
<li>v-once:只会执行一次</li>
<li>v-show:元素隐藏，通过display属性</li>
<li>v-if:元素隐藏</li>
<li>v-for:遍历数组</li>
<li>v-text:渲染字符串</li>
<li>v-html:渲染html</li>
<li>v-model:数据双向绑定</li>
</ul>
<h3 id="Vue中computed和watch有什么区别"><a href="#Vue中computed和watch有什么区别" class="headerlink" title="Vue中computed和watch有什么区别"></a><strong>Vue中computed和watch有什么区别</strong></h3><p><strong>computed:</strong></p>
<ol>
<li>支持缓存，只有依赖数据发生变化时，就会执行计算函数；</li>
<li>不支持异步操作；</li>
<li>计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法；</li>
<li>计算属性是自动监听依赖值的变化，从而动态返回内容。</li>
<li>多条数据影响一条数据时使用计算属性，使用场景购物车。</li>
</ol>
<p><strong>watch:</strong></p>
<ol>
<li>不支持缓存，只要数据发生变化，就会执行侦听函数；</li>
<li>支持异步操作；</li>
<li>侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；</li>
<li>监听的值变化时，可以触发一个回调，做一些其他事情。</li>
<li>一条数据更改，影响多条数据时，使用watch，使用场景搜索框。</li>
</ol>
<h3 id="v-on-如何绑定多个事件？，监听多个事件"><a href="#v-on-如何绑定多个事件？，监听多个事件" class="headerlink" title="v-on 如何绑定多个事件？，监听多个事件"></a><strong>v-on 如何绑定多个事件？，监听多个事件</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; input:onInput,focus:onFocus,blur:onBlur &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue中的data为什么是函数？"><a href="#Vue中的data为什么是函数？" class="headerlink" title="Vue中的data为什么是函数？"></a><strong>Vue中的data为什么是函数？</strong></h3><p>data可以是函数，也可以是对象；</p>
<p>对象，属性存储的地址是同个位置，组件之间的data属性会相互影响；</p>
<p>函数，属性都在函数的作用域内，相互独立，不会影响</p>
<h3 id="vuex-是什么？怎么使用？哪些功能场景使用它？"><a href="#vuex-是什么？怎么使用？哪些功能场景使用它？" class="headerlink" title="vuex 是什么？怎么使用？哪些功能场景使用它？"></a><strong>vuex 是什么？怎么使用？哪些功能场景使用它？</strong></h3><p>vue<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>中状态管理。在 main.js 引入 store，注入。</p>
<p>新建了一个目录store.js，…export。</p>
<p>场景有：单页应用中，组件之间的状态。音乐播放、登陆状态、加入购物车</p>
<h3 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a><strong>vuex有哪几种属性？</strong></h3><p><strong>state</strong></p>
<ul>
<li>存储数据的</li>
<li>获取数据最好推荐使用getters</li>
<li>硬要使用的话可以用MapState， 先引用，放在compute中…mapState([‘方法名’,’方法名’])</li>
</ul>
<p><strong>getters</strong></p>
<ul>
<li>获取数据的</li>
<li>this.$store.getters.xxx</li>
<li>也可使用mapGetters 先引用，放在compute中，…mapGetters([‘方法名’,’方法名’])</li>
</ul>
<p><strong>mutations</strong></p>
<ul>
<li>同步操作数据的</li>
<li>this.$store.commit(“方法名”,数据)</li>
<li>也可使用mapMutations ，使用方法和以上一样</li>
</ul>
<p><strong>actions</strong></p>
<ul>
<li>异步操作数据的</li>
<li>this.$store.dispatch(“方法名”,数据)</li>
<li>也可使用mapActions ，使用方法和以上一样</li>
</ul>
<p><strong>modules</strong></p>
<ul>
<li>板块，里面可以放多个vuex</li>
</ul>
<h3 id="页面刷新后vuex的state数据丢失怎么解决？"><a href="#页面刷新后vuex的state数据丢失怎么解决？" class="headerlink" title="页面刷新后vuex的state数据丢失怎么解决？"></a><strong>页面刷新后vuex的state数据丢失怎么解决？</strong></h3><p>就是放在localStorage 或者就是sessionStorage ，或者借用辅助插vuex-persistedstate</p>
<h3 id="router和-route的区别"><a href="#router和-route的区别" class="headerlink" title="$router和$route的区别"></a><strong>$router和$route的区别</strong></h3><ul>
<li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>
<li>$route 是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>
</ul>
<h3 id="vue路由的方法"><a href="#vue路由的方法" class="headerlink" title="vue路由的方法"></a><strong>vue路由的方法</strong></h3><p>#有两种，分别是声明式和编程式</p>
<p>用router-link进行跳转叫声明式</p>
<p>用js方式进行跳转叫编程式，this.$router.push()</p>
<h3 id="vue路由传参"><a href="#vue路由传参" class="headerlink" title="vue路由传参"></a><strong>vue路由传参</strong></h3><p>路由传参有两种query和params</p>
<p><strong>区别：</strong></p>
<p><strong>query:</strong> </p>
<ol>
<li>参数在url可以看见</li>
<li>页面刷新参数还在</li>
<li>可以使用path或name属性跳转传参</li>
</ol>
<p><strong>params：</strong></p>
<ol>
<li>参数不可见</li>
<li>页面刷新参数不见</li>
<li>必须使用name属性跳转</li>
</ol>
<h3 id="vue导航卫士"><a href="#vue导航卫士" class="headerlink" title="vue导航卫士"></a><strong>vue导航卫士</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;&#125;) <span class="comment">//路由跳转之前触发</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;&#125;) <span class="comment">//路由跳转之后触发</span></span><br><span class="line"><span class="comment">// to：要导航到的目标Route对象，简单点说就是到哪里去。</span></span><br><span class="line"><span class="comment">// form：当前离开的对象，简单点说就是从哪儿来。</span></span><br><span class="line"><span class="comment">// next：必须调用此函数才能解决钩子</span></span><br></pre></td></tr></table></figure>

<h3 id="promise同步-async-await"><a href="#promise同步-async-await" class="headerlink" title="promise同步 async await"></a><strong>promise同步 async await</strong></h3><p>promise是一个对象，用于获取异步操作的数据</p>
<p><strong>优点：</strong></p>
<ol>
<li>避免回调地狱</li>
<li>简介的api，操作更加容易</li>
<li>容易理解，便于维护</li>
<li>容易操作相互依赖的异步请求</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>一旦执行，没办法取消</li>
<li>如果不设置回调函数，内部的错误，没办法抛到外部</li>
<li>不知道当前的状态</li>
</ol>
<p>promise有三个状态：正在请求，成功，失败</p>
<p>async和await必须搭配使用，是promise的语法糖。await之后的代码都被认为是异步代码。强制等待promise执行结束，才继续执行后续代码。</p>
<h2 id="axios-面试题"><a href="#axios-面试题" class="headerlink" title="axios 面试题"></a>axios 面试题</h2><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a><strong>get和post的区别</strong></h3><p>一、</p>
<p><strong>get:</strong> </p>
<ol>
<li>参数可见；</li>
<li>传输数据不超过2-4k；</li>
<li>后退没有影响；</li>
<li>可缓存；</li>
<li>有历史记录</li>
</ol>
<p><strong>post:</strong></p>
<ol>
<li>参数不可见</li>
<li>后退重新提交</li>
<li>不可缓存</li>
<li>没有历史记录</li>
<li>传输数据可以无限大</li>
</ol>
<p>二、</p>
<ol>
<li>GET在浏览器回退不会再次请求，POST会再次提交请求</li>
<li>GET请求会被浏览器主动缓存，POST不会，要手动设置</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>GET参数暴露在地址栏不安全，POST放在报文内部更安全</li>
<li>GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包</li>
</ol>
<h3 id="服务器返回的code意义-http状态码"><a href="#服务器返回的code意义-http状态码" class="headerlink" title="服务器返回的code意义(http状态码)"></a><strong>服务器返回的code意义(http状态码)</strong></h3><ul>
<li>2开头的表示成功<ul>
<li>一般见到的就是200</li>
</ul>
</li>
<li>3开头的表示重定向<ul>
<li>301永久重定向</li>
<li>302临时重定向</li>
<li>304表示可以在缓存中取数据(协商缓存)</li>
</ul>
</li>
<li>4开头表示客户端错误<ul>
<li>401身份未验证</li>
<li>403跨域 (服务器禁止访问)</li>
<li>404未找到 (服务器资源未找到)</li>
</ul>
</li>
<li>5开头表示服务端错误<ul>
<li>500 502服务器内部错误</li>
<li>504 服务器繁忙</li>
</ul>
</li>
</ul>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a><strong>http和https的区别</strong></h3><p>一、</p>
<p>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
<p>https是HTTP运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</p>
<p>二、</p>
<ol>
<li><code>HTTP</code> 的URL 以http:&#x2F;&#x2F; 开头，而<code>HTTPS </code>的URL 以https:&#x2F;&#x2F; 开头</li>
<li><code>HTTP</code> 是不安全的，而 <code>HTTPS </code>是安全的</li>
<li><code>HTTP</code> 标准端口是80 ，而 <code>HTTPS</code> 的标准端口是443</li>
<li><code>在OSI</code> 网络模型中，<code>HTTP工</code>作于应用层，而<code>HTTPS </code>的安全传输机制工作在传输层</li>
<li><code>HTTP</code> 无法加密，而<code>HTTPS </code>对传输的数据进行加密</li>
<li><code>HTTP</code>无需证书，而<code>HTTPS </code>需要CA机构wosign的颁发的SSL证书</li>
</ol>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><strong>同源策略</strong></h3><p> 同源指的是域名、协议、端口号相同</p>
<h3 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a><strong>跨域的解决方案</strong></h3><ul>
<li>JSONP跨域</li>
<li>后端在头部信息里面设置安全域名</li>
<li>Node 中间件代理</li>
</ul>
<h2 id="webpack面试题"><a href="#webpack面试题" class="headerlink" title="webpack面试题"></a>webpack面试题</h2><h3 id="常用Loader（高频）"><a href="#常用Loader（高频）" class="headerlink" title="常用Loader（高频）"></a><strong>常用Loader（高频）</strong></h3><ol>
<li>raw-loader：加载文件原始内容（utf-8）</li>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li>svg-inline-loader：将压缩后的 SVG 内容注入代码中</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>json-loader 加载 JSON 文件（默认包含）</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>ts-loader: 将 TypeScript 转换成 JavaScript</li>
<li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li>
<li>sass-loader：将SCSS&#x2F;SASS代码转换成CSS</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
<li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li>
<li>vue-loader：加载 Vue.js 单文件组件</li>
</ol>
<h3 id="常用的Plugin"><a href="#常用的Plugin" class="headerlink" title="常用的Plugin"></a><strong>常用的Plugin</strong></h3><ol>
<li>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li>
<li>ignore-plugin：忽略部分文件</li>
<li>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</li>
<li>web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li>
<li>uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)</li>
<li>terser-webpack-plugin: 支持压缩 ES6 (Webpack4)</li>
<li>webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</li>
<li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</li>
<li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li>
<li>clean-webpack-plugin: 目录清理</li>
</ol>
<h3 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="headerlink" title="loader 和 plugin 的区别"></a><strong>loader 和 plugin 的区别</strong></h3><p><strong>Loader</strong> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>
<p><strong>Plugin</strong> 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p><strong>Loader</strong> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p>
<p><strong>Plugin</strong> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入</p>
<h2 id="uni-app面试题"><a href="#uni-app面试题" class="headerlink" title="uni-app面试题"></a><strong>uni-app面试题</strong></h2><h3 id="跨端适配—条件编译"><a href="#跨端适配—条件编译" class="headerlink" title="跨端适配—条件编译"></a><strong>跨端适配—条件编译</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//template</span><br><span class="line"><span class="comment">&lt;!--  #ifdef  MP-WEIXIN --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  只在小程序中生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>我是微信小程序<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  #endif --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--  #ifdef  APP-PLUS --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  只在 app 中生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>我是 app <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  #endif --&gt;</span></span><br><span class="line"> </span><br><span class="line">//js</span><br><span class="line">// #ifndef H5</span><br><span class="line">// 表示只有 h5 不使用这个 api</span><br><span class="line">uni.createAnimation(OBJECT)</span><br><span class="line">// #endif</span><br><span class="line"> </span><br><span class="line">//css</span><br><span class="line">/* #ifdef  MP-WEIXIN */</span><br><span class="line">/*  只在小程序中生效  */</span><br><span class="line">.header &#123;</span><br><span class="line">	color:red</span><br><span class="line">&#125;</span><br><span class="line">/*  #endif  */</span><br></pre></td></tr></table></figure>

<h3 id="uniapp的配置文件、入口文件、主组件、页面管理部分"><a href="#uniapp的配置文件、入口文件、主组件、页面管理部分" class="headerlink" title="uniapp的配置文件、入口文件、主组件、页面管理部分"></a><strong>uniapp的配置文件、入口文件、主组件、页面管理部分</strong></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pages.json	配置文件</span><br><span class="line">main.js		入口文件</span><br><span class="line">App.vue		主组件</span><br><span class="line">pages		页面管理部分</span><br><span class="line">   manifest.json 应用的配置文件</span><br><span class="line">   package.json  配置扩展</span><br></pre></td></tr></table></figure>

<h3 id="uni-app的生命周期"><a href="#uni-app的生命周期" class="headerlink" title="uni-app的生命周期"></a><strong>uni-app的生命周期</strong></h3><ul>
<li>onLoad                      监听页面加载</li>
<li>onShow                     监听页面显示</li>
<li>onHide                       监听页面隐藏</li>
<li>onUnload                   监听页面卸载</li>
<li>onPullDownRefresh   监听下拉刷新</li>
<li>onReachBottom         监听滚动到底部</li>
<li>onPageScroll              监听页面滚动</li>
<li>onShareAppMessage 监听用户点击右上角分享</li>
<li>onAddToFavorites       监听用户点击右上角收藏</li>
<li>onShareTimeline         监听用户点击右上角转发到朋友圈</li>
<li>onTabItemTap             点击 tab 时触发</li>
</ul>
<h3 id="路由和页面跳转"><a href="#路由和页面跳转" class="headerlink" title="路由和页面跳转"></a><strong>路由和页面跳转</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uni.navigateTo  保留当前页面，跳转到应用内的某个页面</span><br><span class="line">uni.redirectTo  关闭当前页面，跳转到应用内的某个页面</span><br><span class="line">uni.reLaunch    关闭所有页面，打开到应用内的某个页面</span><br><span class="line">uni.switchTab   跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</span><br><span class="line">uni.navigateBack  关闭当前页面，返回上一页面或多级页面</span><br></pre></td></tr></table></figure>



<h2 id="性能面试题"><a href="#性能面试题" class="headerlink" title="性能面试题"></a>性能面试题</h2><h3 id="请求跨域"><a href="#请求跨域" class="headerlink" title="请求跨域"></a><strong>请求跨域</strong></h3><ol>
<li>jsonp(利用script标签没有跨域限制的漏洞实现。缺点：只支持GET请求)</li>
<li>CORS(设置Access-Control-Allow-Origin：指定可访问资源的域名)</li>
<li>proxy代理 目前常用方式,通过服务器设置代理</li>
<li>利用h5新特性window.postMessage()</li>
</ol>
<h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a><strong>浏览器本地存储</strong></h3><p>浏览器的本地存储主要分为Cookie、localStorage和sessionStorage。</p>
<p><strong>共同点:</strong> 都是保存在浏览器端、且同源的</p>
<p><strong>不同点：</strong></p>
<ol>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</li>
<li>存储大小限制也不同，<ul>
<li>cookie数据不能超过4K，sessionStorage和localStorage可以达到5M</li>
<li>sessionStorage：仅在当前浏览器窗口关闭之前有效；</li>
<li>localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</li>
<li>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li>
</ul>
</li>
<li>作用域不同<ul>
<li>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li>localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</li>
<li>cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在</li>
</ul>
</li>
</ol>
<h2 id="微信小程序面试题"><a href="#微信小程序面试题" class="headerlink" title="微信小程序面试题"></a>微信小程序面试题</h2><h3 id="请谈谈微信小程序主要目录和文件的作用？"><a href="#请谈谈微信小程序主要目录和文件的作用？" class="headerlink" title="请谈谈微信小程序主要目录和文件的作用？"></a><strong>请谈谈微信小程序主要目录和文件的作用？</strong></h3><ul>
<li>project.config.json：项目配置文件，用的最多的就是配置是否开启https校验</li>
<li>App.js：设置一些全局的基础数据等</li>
<li>App.json：底部tab，标题栏和路由等设置</li>
<li>App.wxss：公共样式，引入iconfont等</li>
<li>pages：里面包含一个个具体的页面</li>
<li>index.json：配置当前页面标题和引入组件</li>
<li>index.wxml：页面结构</li>
<li>index.wxss：页面样式表</li>
<li>index.js：页面的逻辑，请求和数据处理</li>
</ul>
<h3 id="请谈谈wxml与标准的html的异同？"><a href="#请谈谈wxml与标准的html的异同？" class="headerlink" title="请谈谈wxml与标准的html的异同？"></a><strong>请谈谈wxml与标准的html的异同？</strong></h3><ul>
<li>都是用来描述页面的结构</li>
<li>都由标签，属性等构成</li>
<li>标签名字不一样，且小程序标签更少，单一标签更多</li>
<li>多了一些 wx:if 这样的属性以及<code>&#123;&#123;&#125;&#125;</code> 这样的表达式</li>
<li>WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览</li>
<li>组件封装不同，WXML对组件进行了重新封装</li>
<li>小程序运行在JS Core内，没有DOM树和windiw对象，小程序中无法使用window对象和document对象。</li>
</ul>
<h3 id="请谈谈WXSS和CSS的异同？"><a href="#请谈谈WXSS和CSS的异同？" class="headerlink" title="请谈谈WXSS和CSS的异同？"></a><strong>请谈谈WXSS和CSS的异同？</strong></h3><ul>
<li>都是用来描述页面的样子</li>
<li>WXSS具有CSS大部分的特性，也做了一些扩充和修改</li>
<li>WXSS新增了尺寸单位，WXSS在底层支持新的尺寸单位rpx</li>
<li>WXSS仅支持部分CSS选择器</li>
<li>WXSS提供全局样式与局部样式</li>
</ul>
<h3 id="你是怎么封装微信小程序的数据请求的？"><a href="#你是怎么封装微信小程序的数据请求的？" class="headerlink" title="你是怎么封装微信小程序的数据请求的？"></a><strong>你是怎么封装微信小程序的数据请求的？</strong></h3><ul>
<li>在根目录下创建util目录及api.js文件和apiConfig.js文件</li>
<li>在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等</li>
<li>在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出</li>
<li>在具体的页面中导入或将所有的接口放在统一的js文件中并导出</li>
<li>在app.js中创建封装请求数据的方法</li>
<li>在子页面中调用封装的请求数据</li>
</ul>
<h3 id="小程序页面之间有哪些（传值）传递数据的方法？"><a href="#小程序页面之间有哪些（传值）传递数据的方法？" class="headerlink" title="小程序页面之间有哪些（传值）传递数据的方法？"></a><strong>小程序页面之间有哪些（传值）传递数据的方法？</strong></h3><ul>
<li>使用全局遍历实现数据传递</li>
<li>页面跳转或重定向时，使用url带参数传递数据</li>
<li>使用组件模板 template传递参数</li>
<li>使用缓存传递参数</li>
<li>使用数据库传递参数或给html元素添加data-*属性来传递值，然后通过e.currentTarget.dataset或onload的param参数获取（data- 名称不能有大写字母，不可以存放对象）</li>
<li>设置id 的方法标识来传值，通过e.currentTarget.id获取设置的id值，然后通过设置全局对象的方式来传递数据</li>
<li>在navigator中添加参数数值</li>
</ul>
<h3 id="请谈谈小程序的双向绑定和vue的异同？"><a href="#请谈谈小程序的双向绑定和vue的异同？" class="headerlink" title="请谈谈小程序的双向绑定和vue的异同？"></a><strong>请谈谈小程序的双向绑定和vue的异同？</strong></h3><p>大体相同，但小程序之间this.data的属性是不可以同步到视图的，必须调用this.setData()方法</p>
<h3 id="请谈谈小程序的生命周期函数"><a href="#请谈谈小程序的生命周期函数" class="headerlink" title="请谈谈小程序的生命周期函数"></a><strong>请谈谈小程序的生命周期函数</strong></h3><ul>
<li>onLoad()页面加载时触发，只会调用一次，可获取当前页面路径中的参数</li>
<li>onShow()页面显示&#x2F;切入前台时候触发，一般用来发送数据请求</li>
<li>onReady()页面初次渲染完成时触发，只会调用一次，代表页面已可和视图层进行交互</li>
<li>onHide()页面隐藏&#x2F;切入后台时触发，如底部tab切换到其他页面或小程序切入后台等</li>
<li>onUnload()页面卸载时触发，如redirectTO或navigateBack到其他页面时</li>
</ul>
<h3 id="简述微信小程序原理"><a href="#简述微信小程序原理" class="headerlink" title="简述微信小程序原理"></a><strong>简述微信小程序原理</strong></h3><ul>
<li>小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</li>
<li>它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；</li>
<li>它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；</li>
<li>功能可分为webview和APPService两个部分，webview主要用来展示UI，appservice用来处理业务逻辑，数据及接口调用，它们在两个进程中进行，通过系统层JSBridge实现通信，实现UI的渲染，事件处理；</li>
<li>webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；</li>
<li>两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。</li>
<li>javaScript的代码是运行在微信App中的，因此一些h5技术的应用需要微信APP提供对应的API支持</li>
<li>wxml 微信自己基于xml语法开发的，因此在开发时只能使用微信提供的现有标签，html的标签是无法使用的</li>
<li>wxss具有css的大部分特性，但并不是所有都支持，没有详细文档（wxss的图片引入需要使用外链地址，没有body，样式可以使用import导入）</li>
</ul>
<h3 id="请谈谈原生开发小程序，wepy，mpvue的对比？"><a href="#请谈谈原生开发小程序，wepy，mpvue的对比？" class="headerlink" title="请谈谈原生开发小程序，wepy，mpvue的对比？"></a><strong>请谈谈原生开发小程序，wepy，mpvue的对比？</strong></h3><ul>
<li>个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。</li>
<li>而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。</li>
<li>而如果如果团队前端强大，自己做一套框架也没问题。</li>
</ul>
<h3 id="简单描述下微信小程序的-相关文件类型"><a href="#简单描述下微信小程序的-相关文件类型" class="headerlink" title="简单描述下微信小程序的 相关文件类型"></a><strong>简单描述下微信小程序的 相关文件类型</strong></h3><ul>
<li><p>wxml 模板文件，是框架设计的一套标签预言，结合基础组件，事件系统，可以构建出页面的结构</p>
</li>
<li><p>wxss 样式文件，是一套样式语言，用于描述WXML的组件样式</p>
</li>
<li><p>js脚本逻辑文件。逻辑处理网络请求</p>
</li>
<li><p>json配置文件，小程序设置，如页面注册，页面标题及tabBar</p>
</li>
<li><p>app.json 整个小程序的全局配置，包括：</p>
<ul>
<li>pages:[所有页面路径]</li>
<li>网络设置（网络超时事件）</li>
<li>页面表现（页面注册）</li>
<li>window：（背景色，导航样式，默认标题）</li>
<li>底部tab等</li>
</ul>
</li>
<li><p>app.js 监听并处理小程序的生命周期函数，声明全局变量</p>
</li>
<li><p>app.wxss 全局配置的样式文件<br>​</p>
</li>
</ul>
<h3 id="那些方法来提高微信小程序的应用速度？"><a href="#那些方法来提高微信小程序的应用速度？" class="headerlink" title="那些方法来提高微信小程序的应用速度？"></a><strong>那些方法来提高微信小程序的应用速度？</strong></h3><ul>
<li>提高页面的加载速度</li>
<li>用户行为预测</li>
<li>减少默认的data的大小</li>
<li>组件化方案</li>
</ul>
<h3 id="分析微信小程序的优劣势？"><a href="#分析微信小程序的优劣势？" class="headerlink" title="分析微信小程序的优劣势？"></a><strong>分析微信小程序的优劣势？</strong></h3><p><strong>优势：</strong></p>
<ul>
<li><p>容易上手，基础组件库比较全，基本不需要考虑兼容问题</p>
</li>
<li><p>开发文档比较完善，开发社区比较活跃，支持插件式开发</p>
</li>
<li><p>良好的用户体验，无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多</p>
</li>
<li><p>开发成本比APP要低</p>
</li>
<li><p>为用户提供良好的保障（小程序发布，严格是审查流程）</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>限制较多，页面大小不能超过1M，不能打开超过5个层级的页面</li>
<li>样式单一，部分组件已经是成型的，样式不可修改，例如：幻灯片，导航</li>
<li>推广面窄，不能分享朋友圈，只能通过分享给朋友，附加小程序推广</li>
<li>依托与微信，无法开发后台管理功能</li>
<li>后台调试麻烦，因为api接口必须https请求且公网地址</li>
<li>真机测试，个别安卓和苹果表现迥异，例如安卓的定位功能加载很慢</li>
</ul>
<h3 id="微信小程序和H5的区别？"><a href="#微信小程序和H5的区别？" class="headerlink" title="微信小程序和H5的区别？"></a><strong>微信小程序和H5的区别？</strong></h3><ul>
<li>运行环境不同（小程序在微信运行，h5在浏览器运行）</li>
<li>开发成本不同（h5需要兼容不同的浏览器）</li>
<li>获取系统权限不同（系统级权限可以和小程序无缝衔接）</li>
<li>应用在生成环境的运行速度流程（h5需不断对项目优化来提高用户体验）</li>
</ul>
<h3 id="小程序关联微信公众号如何确定用户的唯一性？"><a href="#小程序关联微信公众号如何确定用户的唯一性？" class="headerlink" title="小程序关联微信公众号如何确定用户的唯一性？"></a><strong>小程序关联微信公众号如何确定用户的唯一性？</strong></h3><p>使用wx.getUserlnfo方法 withCredentials为true时，可获取encryptedData，里面有union_id，后端需要进行对称解密</p>
<h3 id="使用webview直接加载要注意那些事项？"><a href="#使用webview直接加载要注意那些事项？" class="headerlink" title="使用webview直接加载要注意那些事项？"></a><strong>使用webview直接加载要注意那些事项？</strong></h3><ul>
<li>必须要在小程序后台使用管理员添加业务域名</li>
<li>h5页面跳转至小程序的脚步必须是1.3.1以上</li>
<li>微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上</li>
<li>h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的</li>
</ul>
<h3 id="小程序调用后台接口遇到那些问题？"><a href="#小程序调用后台接口遇到那些问题？" class="headerlink" title="小程序调用后台接口遇到那些问题？"></a><strong>小程序调用后台接口遇到那些问题？</strong></h3><ul>
<li>数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序</li>
<li>小程序不可以直接渲染文章内容这类型的html文本，显示需要借助插件</li>
</ul>
<p>注：插件渲染会导致页面加载变慢，建议在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其他的标签让插件来做</p>
<h3 id="微信小程序如何实现下拉刷新？"><a href="#微信小程序如何实现下拉刷新？" class="headerlink" title="微信小程序如何实现下拉刷新？"></a><strong>微信小程序如何实现下拉刷新？</strong></h3><p>用view代替scroll-view，设置onPullDownRefresh函数实现</p>
<h3 id="webview中的页面怎么跳转回小程序"><a href="#webview中的页面怎么跳转回小程序" class="headerlink" title="webview中的页面怎么跳转回小程序"></a><strong>webview中的页面怎么跳转回小程序</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="property">miniProgram</span>.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;pages/login/login&#x27;</span>+<span class="string">&#x27;$params&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//跳转到小程序导航页面</span></span><br><span class="line">wx.<span class="property">miniProgram</span>.<span class="title function_">switchTab</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;/pages/index/index&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="bindtap和catchtap的区别？"><a href="#bindtap和catchtap的区别？" class="headerlink" title="bindtap和catchtap的区别？"></a><strong>bindtap和catchtap的区别？</strong></h3><ul>
<li>bind事件绑定不会阻止冒泡事件向上冒泡</li>
<li>catch事件绑定可以阻止冒泡事件向上冒泡</li>
</ul>
<h3 id="简述wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别？"><a href="#简述wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别？" class="headerlink" title="简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？"></a><strong>简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？</strong></h3><ul>
<li>在wxml页面中：跳转新页面，在当前页打开，切换到首页Tab</li>
<li>在js页面中：分为应用内的页面，和tabBar页面</li>
<li>如果上述跳转遇到跳转失败或者无效的问题，请访问：wx.navigateTo&#x2F;wx.redirectTo无效</li>
</ul>
<h3 id="小程序和Vue写法的区别？"><a href="#小程序和Vue写法的区别？" class="headerlink" title="小程序和Vue写法的区别？"></a><strong>小程序和Vue写法的区别？</strong></h3><ul>
<li>遍历的时候：小程序wx:for&#x3D;“list”,而Vue是v-for&#x3D;“item in list”</li>
<li>调用data模型（赋值）的时候：<ul>
<li>小程序：this.data.item &#x2F;&#x2F; 调用，this.setDate({item:1})&#x2F;&#x2F;赋值</li>
<li>Vue：this.item &#x2F;&#x2F;调用，this.item&#x3D;1 &#x2F;&#x2F;赋值<br>​</li>
</ul>
</li>
</ul>
<h3 id="小程序与原生App那个好？"><a href="#小程序与原生App那个好？" class="headerlink" title="小程序与原生App那个好？"></a><strong>小程序与原生App那个好？</strong></h3><p>各有各自的优点，都又有缺点</p>
<p>小程序的优点：</p>
<ol>
<li><p>基于微信平台开发，享受微信自带的流量，这个优点最大</p>
</li>
<li><p>无需安装，只要打开微信就能用，不占手机内存，体验好</p>
</li>
<li><p>开发周期段，一般最多一个月就可以上线完成</p>
</li>
<li><p>开发所需的资金少，所需资金是开发原生APP的一半不到</p>
</li>
<li><p>小程序名称是唯一的，在微信的搜索里权重很高</p>
</li>
<li><p>容易上手，只要之前有HTML+CSS+JS基础知识，写小程序基本没有大问题</p>
</li>
<li><p>基本不需要考虑兼容性问题，只要微信可以正常运行的机器，就可以运行小程序</p>
</li>
<li><p>发布，审核高效，基本上午发布审核，下午就审核通过，升级简单，支持灰度发布</p>
</li>
<li><p>开发文档完善，社区活跃</p>
</li>
<li><p>支持插件式开发，一些基本功能可以开发成插件，供多个小程序使用</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>局限性很强（比如页面大小不能超过1M，不能打开超过5个层级的页面，样式单一，小程序的部分组件已经是成型的了，样式不能修改，比如幻灯片，导航）只能依赖于微信依托与微信，无法开发后台管理功能</p>
</li>
<li><p>不利于推广，推广面窄，不能分享朋友圈，只能分享给朋友，附近小程序推广，其中附加小程序也收到微信限制</p>
</li>
<li><p>后台调试麻烦，因为API接口必须https请求，且公网地址，也就是说后台代码必须发布到远程服务器上；当然我们可以修改host进行dns映射把远程服务器转到本地，或者开启tomcat远程调试；不管怎么说终归调试比较麻烦</p>
</li>
<li><p>前台测试有诸多坑，最头疼莫过于模拟器与真机显示不一致</p>
</li>
<li><p>js引用只能使用绝对路径，不能操作DOM</p>
</li>
</ol>
<p>原生App优点：</p>
<ol>
<li><p>原生的相应速度快</p>
</li>
<li><p>对于有无网络操作时，譬如离线操作基本选用原生开发</p>
</li>
<li><p>需要调用系统硬件的功能（摄像头，拨号，短信蓝牙…）</p>
</li>
<li><p>在无网络或者弱网情况下体验好</p>
</li>
</ol>
<p>原生App缺点：</p>
<p>开发周期长，开发成本高，需要下载</p>
<h3 id="小程序的发布流程（开发流程）"><a href="#小程序的发布流程（开发流程）" class="headerlink" title="小程序的发布流程（开发流程）"></a><strong>小程序的发布流程（开发流程）</strong></h3><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ssrstm/p/6855572.html">https://www.cnblogs.com/ssrstm/p/6855572.html</a></p>
<ol>
<li>注册微信小程序账号</li>
<li>获取微信小程序的AppID</li>
<li>下载微信小程序开发者工具</li>
<li>创建demo项目</li>
<li>去微信公众号配置域名</li>
<li>手机浏览</li>
<li>代码上传</li>
<li>提交审核</li>
<li>小程序发布</li>
</ol>
<h3 id="webview中的页面怎么跳回小程序中？"><a href="#webview中的页面怎么跳回小程序中？" class="headerlink" title="webview中的页面怎么跳回小程序中？"></a><strong>webview中的页面怎么跳回小程序中？</strong></h3><p>首先，需要在你的html页面中引用一个js文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;https://res.wx.qq.com/open/js/jweixin-1.3.0.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">//然后为你的按钮标签注册一个点击事件</span></span><br><span class="line">$(<span class="string">&quot;.kaiqi&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        wx.<span class="property">miniProgram</span>.<span class="title function_">redirectTo</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;/pages/indexTwo/indexTwo&#x27;</span>&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里的redirectTo跟小程序的wx.redirectTo()跳转页面是一样的，会关闭当前跳转到页面，换成navigateTo，跳转页面就不会关闭当前页面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小程序授权登录流程"><a href="#小程序授权登录流程" class="headerlink" title="小程序授权登录流程"></a><strong>小程序授权登录流程</strong></h3><p>（授权，微信登录获取code，微信登录，获取iv , encryptedData 传到服务器后台，如果没有注册，需要注册。）</p>
<h3 id="小程序支付如何实现？"><a href="#小程序支付如何实现？" class="headerlink" title="小程序支付如何实现？"></a><strong>小程序支付如何实现？</strong></h3><ol>
<li><p>小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限</p>
</li>
<li><p>绑定商户号</p>
</li>
<li><p>在小程序填写合法域</p>
</li>
<li><p>调用wx.login()获取appid</p>
</li>
<li><p>调用</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wx.requestPayment(</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;timeStamp&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span><span class="comment">//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间</span></span><br><span class="line">    &#x27;nonceStr&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span><span class="comment">//随机字符串，长度为32个字符以下。</span></span><br><span class="line">    &#x27;package&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span><span class="comment">//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*</span></span><br><span class="line">    &#x27;signType&#x27;<span class="punctuation">:</span> &#x27;MD5&#x27;<span class="punctuation">,</span><span class="comment">//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致</span></span><br><span class="line">    &#x27;paySign&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span><span class="comment">//签名,具体签名方案参见微信公众号支付帮助文档;</span></span><br><span class="line">    &#x27;success&#x27;<span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//成功回调</span></span><br><span class="line">    &#x27;fail&#x27;<span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">//失败</span></span><br><span class="line">    &#x27;complete&#x27;<span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="comment">//接口调用结束的回调函数（调用成功、失败都会执行）</span></span><br><span class="line"><span class="punctuation">&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wxpay.png" alt="微信支付"></p>
</li>
</ol>
<h3 id="小程序还有那些功能？"><a href="#小程序还有那些功能？" class="headerlink" title="小程序还有那些功能？"></a><strong>小程序还有那些功能？</strong></h3><p>客服功能，录音，视频，音频，地图，定位，拍照，动画，canvas</p>
<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a><strong>常见问题：</strong></h3><ol>
<li>rpx：小程序的尺寸单位，规定屏幕为750rpx，可适配不同分辨率屏幕</li>
<li>本地资源无法通过wxss获取：background-image：可以使用网络图片，或者base64，或者使用标签</li>
<li>wx.navigateTo无法打开页面：一个应用同时只能打开5个页面，请避免多层级的交互方式，或使用wx.redirectTo</li>
<li>tabBar设置不显示：1.tabBar的数量少于2项或超过5项都不会显示。2.tabBar写法错误导致不会显示。3.tabBar没有写pagePath字段（程序启动后显示的第一个页面）</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">前端面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/four.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/img/qq.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/qq.jpg" alt="QQ"/></a><div class="post-qr-code-desc">QQ</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/30366.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tent.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常用开发需要的软件跟插件</div></div></a></div><div class="next-post pull-right"><a href="/12009.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/serve.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PC端与手机端相互跳转</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/66666.html" title="前端面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tent.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-15</div><div class="title">前端面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ga.x</div><div class="author-info__description">Ga.X个人博客,记录个人学习,分享一些无用的方法跟技巧；小兔鲜商城项目在线网址：dididididii.xyz;参考源码在关于页面查看。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dididididii"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dididididii" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_48023110" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1281627297&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1281627297@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">此博客纯属分享一些无用的东西,希望各大佬喷轻点,本人只会复制粘贴。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">前端面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">输入一个URL到页面过程中发生了什么（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E3%80%81%E9%87%8D%E7%BB%98%E3%80%81%E9%87%8D%E6%8E%92"><span class="toc-number">1.1.2.</span> <span class="toc-text">浏览器渲染机制、重绘、重排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-CSS"><span class="toc-number">1.2.</span> <span class="toc-text">HTML+ CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">HTML语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.2.</span> <span class="toc-text">语义化标签有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#meta-x2F-viewport-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">meta &#x2F; viewport 标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-%E5%92%8C-SVG-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">Canvas 和 SVG 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H5-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">H5 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-HTML5-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">说说 HTML5 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">1.2.8.</span> <span class="toc-text">如何实现垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex-%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.9.</span> <span class="toc-text">flex 怎么用，常用属性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.10.</span> <span class="toc-text">BFC 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#content-box%E5%92%8Cborder-box%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.11.</span> <span class="toc-text">content-box和border-box区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A9Chrome%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-number">1.2.12.</span> <span class="toc-text">怎么让Chrome支持小于12px的文字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css3%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.13.</span> <span class="toc-text">css3特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.14.</span> <span class="toc-text">iframe的优缺点有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#px%E3%80%81em%E3%80%81rem%E3%80%81vh-x2F-vw%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.15.</span> <span class="toc-text">px、em、rem、vh&#x2F;vw的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.16.</span> <span class="toc-text">css选择器有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">1.2.17.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.18.</span> <span class="toc-text">伪类和伪元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%B7%A6%E4%B8%AD%E5%8F%B3%E5%B8%83%E5%B1%80%E5%8D%A0%E6%BB%A1%E5%B1%8F%E5%B9%95%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%B7%A6%E5%8F%B3%E4%B8%A4%E5%9D%97%E6%98%AF%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6200-%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%BD"><span class="toc-number">1.2.19.</span> <span class="toc-text">写一个左中右布局占满屏幕，其中左右两块是固定宽度200 ，中间自适应宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%9D%A10-5%E7%9A%84%E7%BA%BF%EF%BC%9F"><span class="toc-number">1.2.20.</span> <span class="toc-text">如何画一条0.5的线？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.2.21.</span> <span class="toc-text">css绘制三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E5%86%99%E5%87%BA3%E7%A7%8D%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.22.</span> <span class="toc-text">分别写出3种垂直居中的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">JavaScript面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E5%B1%95%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">从输入url到展示页面加载的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">三次握手和四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">为什么是三次握手不是两次握手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">为什么js是单线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">如何实现异步编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.6.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">1.3.7.</span> <span class="toc-text">回流和重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2"><span class="toc-number">1.3.8.</span> <span class="toc-text">网页中有大量的图片加载很慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%92%8CBOM"><span class="toc-number">1.3.9.</span> <span class="toc-text">DOM和BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">1.3.10.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.11.</span> <span class="toc-text">普通函数和构造函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.3.12.</span> <span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.13.</span> <span class="toc-text">JS垃圾回收机制是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.14.</span> <span class="toc-text">JS垃圾回收方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">1.3.15.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.3.16.</span> <span class="toc-text">什么是浏览器缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.17.</span> <span class="toc-text">使用缓存的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.18.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.19.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87"><span class="toc-number">1.3.20.</span> <span class="toc-text">变量和函数声明的提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.21.</span> <span class="toc-text">数组常用的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AFNaN"><span class="toc-number">1.3.22.</span> <span class="toc-text">判断数据是NaN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick"><span class="toc-number">1.3.23.</span> <span class="toc-text">$nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.24.</span> <span class="toc-text">new 做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.25.</span> <span class="toc-text">谈谈this对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">1.3.26.</span> <span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.27.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%98-x3D-x3D-%E2%80%99%E8%B7%9F%E2%80%99-x3D-x3D-x3D-%E2%80%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.28.</span> <span class="toc-text">‘&#x3D;&#x3D;’跟’&#x3D;&#x3D;&#x3D;’的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.29.</span> <span class="toc-text">var let const的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined%E5%92%8Cnull"><span class="toc-number">1.3.30.</span> <span class="toc-text">undefined和null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.31.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.3.32.</span> <span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.3.33.</span> <span class="toc-text">原型与原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies-sessionStorage%E5%92%8Clocalstorage%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.34.</span> <span class="toc-text">cookies sessionStorage和localstorage区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-bind-call%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.35.</span> <span class="toc-text">apply,bind,call的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.36.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.37.</span> <span class="toc-text">typeof和instanceof的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.38.</span> <span class="toc-text">ES6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.3.39.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%8E%BB%E9%87%8D"><span class="toc-number">1.3.40.</span> <span class="toc-text">数组对象去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.41.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.42.</span> <span class="toc-text">深拷贝和浅拷贝的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">Vue面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E5%92%8CMVVM"><span class="toc-number">1.4.1.</span> <span class="toc-text">MVC和MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E7%9C%9F%E5%AE%9EDOM"><span class="toc-number">1.4.2.</span> <span class="toc-text">虚拟DOM和真实DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">vue全家桶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9BVue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">做过哪些Vue的性能优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.4.5.</span> <span class="toc-text">Vue的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.6.</span> <span class="toc-text">vue的自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.8.</span> <span class="toc-text">vue中父子组件的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.9.</span> <span class="toc-text">v-if和v-for为什么不能同时使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.10.</span> <span class="toc-text">Vue兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%AD-keep-alive-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.11.</span> <span class="toc-text">Vue 中 keep-alive 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-0%E5%92%8Cvue3-0%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.12.</span> <span class="toc-text">vue2.0和vue3.0区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%AD-V-bind-%E5%92%8C-V-model-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.13.</span> <span class="toc-text">Vue 中 V-bind 和 V-model 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD-created-%E5%92%8C-mounted-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.14.</span> <span class="toc-text">Vue 生命周期中 created 和 mounted 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.15.</span> <span class="toc-text">Vue路由有哪些模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">1.4.16.</span> <span class="toc-text">插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.4.17.</span> <span class="toc-text">vue双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.18.</span> <span class="toc-text">vue双向绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.19.</span> <span class="toc-text">Vue中key的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.20.</span> <span class="toc-text">常用的事件修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.21.</span> <span class="toc-text">Vue常用的指令有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%ADcomputed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.22.</span> <span class="toc-text">Vue中computed和watch有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-on-%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9F%EF%BC%8C%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.23.</span> <span class="toc-text">v-on 如何绑定多个事件？，监听多个事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.4.24.</span> <span class="toc-text">Vue中的data为什么是函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">1.4.25.</span> <span class="toc-text">vuex 是什么？怎么使用？哪些功能场景使用它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.4.26.</span> <span class="toc-text">vuex有哪几种属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8Evuex%E7%9A%84state%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.4.27.</span> <span class="toc-text">页面刷新后vuex的state数据丢失怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router%E5%92%8C-route%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.28.</span> <span class="toc-text">$router和$route的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.29.</span> <span class="toc-text">vue路由的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">1.4.30.</span> <span class="toc-text">vue路由传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%AF%BC%E8%88%AA%E5%8D%AB%E5%A3%AB"><span class="toc-number">1.4.31.</span> <span class="toc-text">vue导航卫士</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%90%8C%E6%AD%A5-async-await"><span class="toc-number">1.4.32.</span> <span class="toc-text">promise同步 async await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">axios 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.</span> <span class="toc-text">get和post的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E7%9A%84code%E6%84%8F%E4%B9%89-http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">服务器返回的code意义(http状态码)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.</span> <span class="toc-text">http和https的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.5.</span> <span class="toc-text">跨域的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">webpack面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8Loader%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">常用Loader（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Plugin"><span class="toc-number">1.6.2.</span> <span class="toc-text">常用的Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader-%E5%92%8C-plugin-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.</span> <span class="toc-text">loader 和 plugin 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uni-app%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">uni-app面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E7%AB%AF%E9%80%82%E9%85%8D%E2%80%94%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">1.7.1.</span> <span class="toc-text">跨端适配—条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniapp%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E3%80%81%E4%B8%BB%E7%BB%84%E4%BB%B6%E3%80%81%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E9%83%A8%E5%88%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">uniapp的配置文件、入口文件、主组件、页面管理部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uni-app%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">uni-app的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.7.4.</span> <span class="toc-text">路由和页面跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">性能面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">请求跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">浏览器本地存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.9.</span> <span class="toc-text">微信小程序面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">请谈谈微信小程序主要目录和文件的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88wxml%E4%B8%8E%E6%A0%87%E5%87%86%E7%9A%84html%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">请谈谈wxml与标准的html的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88WXSS%E5%92%8CCSS%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">请谈谈WXSS和CSS的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-number">1.9.4.</span> <span class="toc-text">你是怎么封装微信小程序的数据请求的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E4%BC%A0%E5%80%BC%EF%BC%89%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.9.5.</span> <span class="toc-text">小程序页面之间有哪些（传值）传递数据的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8Cvue%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">1.9.6.</span> <span class="toc-text">请谈谈小程序的双向绑定和vue的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.7.</span> <span class="toc-text">请谈谈小程序的生命周期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.8.</span> <span class="toc-text">简述微信小程序原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cwepy%EF%BC%8Cmpvue%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">1.9.9.</span> <span class="toc-text">请谈谈原生开发小程序，wepy，mpvue的对比？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84-%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.10.</span> <span class="toc-text">简单描述下微信小程序的 相关文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.9.11.</span> <span class="toc-text">那些方法来提高微信小程序的应用速度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%EF%BC%9F"><span class="toc-number">1.9.12.</span> <span class="toc-text">分析微信小程序的优劣势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8CH5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.13.</span> <span class="toc-text">微信小程序和H5的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F"><span class="toc-number">1.9.14.</span> <span class="toc-text">小程序关联微信公众号如何确定用户的唯一性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8webview%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%A6%81%E6%B3%A8%E6%84%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">1.9.15.</span> <span class="toc-text">使用webview直接加载要注意那些事项？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E9%81%87%E5%88%B0%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.9.16.</span> <span class="toc-text">小程序调用后台接口遇到那些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">1.9.17.</span> <span class="toc-text">微信小程序如何实现下拉刷新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webview%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E5%9B%9E%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.9.18.</span> <span class="toc-text">webview中的页面怎么跳转回小程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bindtap%E5%92%8Ccatchtap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.19.</span> <span class="toc-text">bindtap和catchtap的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.20.</span> <span class="toc-text">简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8CVue%E5%86%99%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.21.</span> <span class="toc-text">小程序和Vue写法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8E%9F%E7%94%9FApp%E9%82%A3%E4%B8%AA%E5%A5%BD%EF%BC%9F"><span class="toc-number">1.9.22.</span> <span class="toc-text">小程序与原生App那个好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%EF%BC%88%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">1.9.23.</span> <span class="toc-text">小程序的发布流程（开发流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webview%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%80%8E%E4%B9%88%E8%B7%B3%E5%9B%9E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%EF%BC%9F"><span class="toc-number">1.9.24.</span> <span class="toc-text">webview中的页面怎么跳回小程序中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.25.</span> <span class="toc-text">小程序授权登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.9.26.</span> <span class="toc-text">小程序支付如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%98%E6%9C%89%E9%82%A3%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.9.27.</span> <span class="toc-text">小程序还有那些功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.9.28.</span> <span class="toc-text">常见问题：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/48515.html" title="防抖与节流"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/eigth.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="防抖与节流"/></a><div class="content"><a class="title" href="/48515.html" title="防抖与节流">防抖与节流</a><time datetime="2022-09-30T08:00:44.000Z" title="发表于 2022-09-30 16:00:44">2022-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/30366.html" title="常用开发需要的软件跟插件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tent.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用开发需要的软件跟插件"/></a><div class="content"><a class="title" href="/30366.html" title="常用开发需要的软件跟插件">常用开发需要的软件跟插件</a><time datetime="2022-09-07T05:06:55.000Z" title="发表于 2022-09-07 13:06:55">2022-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61730.html" title="2022新版前端面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/four.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022新版前端面试题"/></a><div class="content"><a class="title" href="/61730.html" title="2022新版前端面试题">2022新版前端面试题</a><time datetime="2022-09-07T05:02:13.000Z" title="发表于 2022-09-07 13:02:13">2022-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/12009.html" title="PC端与手机端相互跳转"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/serve.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PC端与手机端相互跳转"/></a><div class="content"><a class="title" href="/12009.html" title="PC端与手机端相互跳转">PC端与手机端相互跳转</a><time datetime="2022-08-28T15:26:36.000Z" title="发表于 2022-08-28 23:26:36">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9352.html" title="vue2.0商品放大镜参照写法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/four.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue2.0商品放大镜参照写法"/></a><div class="content"><a class="title" href="/9352.html" title="vue2.0商品放大镜参照写法">vue2.0商品放大镜参照写法</a><time datetime="2022-08-28T15:18:01.000Z" title="发表于 2022-08-28 23:18:01">2022-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/four.webp')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ga.x</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>