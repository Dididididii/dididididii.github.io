<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试题 | Ga.X个人博客</title><meta name="keywords" content="前端面试题"><meta name="author" content="Ga.x"><meta name="copyright" content="Ga.x"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML 面试题1、HTML 语义化博客链接  是什么: 语义化标签是一 种写 HTML 标签的方法论&#x2F;方式。 怎么做:实现方法是遇到标题就用 h1 到 h6,遇到段落用 p,遇到文章用 article,主要内容用 main, 边栏用 aside,导航用 nav ….. (就是找到中文对应的英文) 解决了什么问题:明确了 HTML 的书写规范 优点是:一、适合搜索引擎检索;二、 适合人类">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="https://blog.gadii.top/66666.html">
<meta property="og:site_name" content="Ga.X个人博客">
<meta property="og:description" content="HTML 面试题1、HTML 语义化博客链接  是什么: 语义化标签是一 种写 HTML 标签的方法论&#x2F;方式。 怎么做:实现方法是遇到标题就用 h1 到 h6,遇到段落用 p,遇到文章用 article,主要内容用 main, 边栏用 aside,导航用 nav ….. (就是找到中文对应的英文) 解决了什么问题:明确了 HTML 的书写规范 优点是:一、适合搜索引擎检索;二、 适合人类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.gadii.top/img/tent.webp">
<meta property="article:published_time" content="2022-07-15T03:20:36.000Z">
<meta property="article:modified_time" content="2022-09-07T05:04:02.328Z">
<meta property="article:author" content="Ga.x">
<meta property="article:tag" content="前端面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.gadii.top/img/tent.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.gadii.top/66666"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Ga.x","link":"链接: ","source":"来源: Ga.X个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-07 13:04:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/tent.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ga.X个人博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-15T03:20:36.000Z" title="发表于 2022-07-15 11:20:36">2022-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-07T05:04:02.328Z" title="更新于 2022-09-07 13:04:02">2022-09-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML-面试题"><a href="#HTML-面试题" class="headerlink" title="HTML 面试题"></a><strong>HTML 面试题</strong></h1><h2 id="1、HTML-语义化"><a href="#1、HTML-语义化" class="headerlink" title="1、HTML 语义化"></a>1、HTML 语义化</h2><p><a href="./52657.html">博客链接</a></p>
<ul>
<li>是什么: 语义化标签是一 种写 HTML 标签的方法论&#x2F;方式。</li>
<li>怎么做:实现方法是遇到标题就用 h1 到 h6,遇到段落用 p,遇到文章用 article,主要内容用 main, 边栏用 aside,导航用 nav ….. (就是找到中文对应的英文)</li>
<li>解决了什么问题:明确了 HTML 的书写规范</li>
<li>优点是:一、适合搜索引擎检索;二、 适合人类阅读,利于团队维护。</li>
<li>缺点:没有</li>
</ul>
<h2 id="2、meta-x2F-viewport-标签"><a href="#2、meta-x2F-viewport-标签" class="headerlink" title="2、meta &#x2F; viewport 标签"></a>2、meta &#x2F; viewport 标签</h2><p><a href="./52658.html">博客链接</a></p>
<p>github+上有个仓库，叫+HEAD+的仓库：<a target="_blank" rel="noopener" href="https://github.com/joshbuchea/HEAD">仓库地址</a>，这个仓库就把所有流行的+meta+写法都告诉我们了</p>
<h3 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h3><ol>
<li>meta 标签是 HTML 语言 HEAD 区的一个辅助性标签</li>
<li>meta 标签-般用于描述 HTML 网页的属性,例如:作者、关键字、网页描述、和其它的元数据」</li>
</ol>
<h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>​ viewport 是用户网页的可视区域,也叫视口、视区</p>
<p>主要是用来适配移动端的，比如:不让用户在移动端对页面进行缩放</p>
<p>我一般是拷贝淘宝网移动端的 viewport</p>
<h2 id="3、用过哪些-HTML5-标签"><a href="#3、用过哪些-HTML5-标签" class="headerlink" title="3、用过哪些 HTML5 标签"></a>3、用过哪些 HTML5 标签</h2><p>别给自己挖坑!只说熟悉的标签,不要提不熟悉的标签</p>
<p>内容相关的: header、 section、 main、 footer、 article…</p>
<p>功能相关的: type&#x3D;email、 type&#x3D;tell</p>
<h2 id="4、Canvas-和-SVG-的区别"><a href="#4、Canvas-和-SVG-的区别" class="headerlink" title="4、Canvas 和 SVG 的区别"></a>4、Canvas 和 SVG 的区别</h2><blockquote>
<p>区分题答题思路为:先说一,再说二，再说相同点，最后说不同点。</p>
</blockquote>
<p><a href="./52659.html">博客链接</a></p>
<ol>
<li>Canvas 主要是用笔刷来绘制 2D 图形的。</li>
<li>SVG 主要是用标签来绘制不规则矢量图的。</li>
<li>相同点:都是主要用来画 2D 图形的。</li>
<li>不同点: Canvas 画的是位图，SVG 画的是矢量图。</li>
<li>不同点: SVG 节点过多时渲染慢， Canvas 性能更好一-点, 但写起来更复杂。</li>
<li>不同点: SVG 支持分层和事件，Canvas 不支持，但是可以用库实现。</li>
</ol>
<h2 id="5、H5-是什么"><a href="#5、H5-是什么" class="headerlink" title="5、H5 是什么"></a>5、H5 是什么</h2><blockquote>
<p>抽象问题</p>
</blockquote>
<p>H5 就是移动端页面，反正不是 HTML5。</p>
<h1 id="CSS-面试题"><a href="#CSS-面试题" class="headerlink" title="CSS 面试题"></a><strong>CSS 面试题</strong></h1><h2 id="1、两种盒模型的区别"><a href="#1、两种盒模型的区别" class="headerlink" title="1、两种盒模型的区别"></a>1、两种盒模型的区别</h2><blockquote>
<p>区分题:说一下这两种是什么，再说相同点，最后说不同点</p>
</blockquote>
<p><a href="./52660.html">博客链接</a></p>
<ul>
<li>第一种盒模型是 content-box, 即 width 指定的是 content 区域宽度，而不是实际宽度，公式为</li>
</ul>
<blockquote>
<p>实际宽度&#x3D; width + padding + border</p>
</blockquote>
<ul>
<li>第二种盒模型是 border-box,即 width 指定的是左右边框外侧的距离，公式为</li>
</ul>
<blockquote>
<p>实际宽度&#x3D; width</p>
</blockquote>
<ul>
<li>相同点都是用来指定宽度的,同点是 border-box 更好用，因为 content-box 还需要算, border-box 多宽就多宽。</li>
</ul>
<p>拔高点:说出为什么会有这种新的盒模型,关键词:这种比那种写起来更方便</p>
<h2 id="2、如何实现垂直居中？"><a href="#2、如何实现垂直居中？" class="headerlink" title="2、如何实现垂直居中？"></a>2、如何实现垂直居中？</h2><p>1、通过 verticle-align:middle 实现 CSS 垂直居中。</p>
<p>2、通过 display:flex 实现 CSS 垂直居中。</p>
<p>3、通过伪元素:before 实现 CSS 垂直居中。</p>
<p>4、通过 display:table-cell 实现 CSS 垂直居中。</p>
<p>5、通过隐藏节点实现 CSS 垂直居中。</p>
<p>6、已知父元素高度通过 transform 实现 CSS 垂直居中。</p>
<p>7、到垂直居中的位置。</p>
<p>8、通过 line-height 实现 CSS 垂直居中。</p>
<p><strong>通用办法：body 加 display：flex 居中盒子加 margin：auto</strong></p>
<h2 id="3、flex-怎么用，常用属性有哪些？"><a href="#3、flex-怎么用，常用属性有哪些？" class="headerlink" title="3、flex 怎么用，常用属性有哪些？"></a>3、flex 怎么用，常用属性有哪些？</h2><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>实现 flex 布局，首先我们需要有一个使用 flex 布局的元素，称为 flex container，简称”容器”。</p>
<p>容器中每个元素称为 flex item，简称”物品”。</p>
<p>容器默认有两根轴：水平的主轴(main axis) 和 交叉轴(cross axis)。</p>
<h3 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h3><ul>
<li>flex-direction: 设置主轴的方向 （<strong>row（默认值）：</strong>主轴为水平方向，起点在左端；<strong>row-reverse：</strong>主轴为水平方向，起点在右端；<strong>column：</strong>主轴为垂直方向，起点在上沿；<strong>column-reverse：</strong>主轴为垂直方向，起点在下沿；）</li>
<li>justify-content: 设置主轴上的子元素排列方式（<strong>flex-start（默认值）：</strong>起点对齐；<strong>flex-end：</strong>终点对齐；<strong>center：</strong>居中；<strong>space-between：</strong>两端对齐，物品之间的间隔相等；<strong>space-around：</strong>每个物品两侧的间隔相等）</li>
<li>flex-wrap: 设置子元素是否换行（<strong>nowrap（默认）：</strong>不换行；<strong>wrap：</strong>换行，第一行在上方；<strong>wrap-reverse：</strong>换行，第一行在下方；）</li>
<li>align-content: 设置侧轴的子元素的排列方式（多行）（<strong>stretch（默认值）：</strong>多行占满整个交叉轴；<strong>flex-start：</strong>与交叉轴的起点对齐；<strong>flex-end：</strong>与交叉轴的终点对齐；<strong>center：</strong>与交叉轴的居中点对齐；<strong>space-between：</strong>与交叉轴两端对齐，轴线之间的间隔平均分布；<strong>space-around：</strong>每根轴线两侧的间隔都相等）</li>
<li>align-items:设置侧轴上的子元素排列方式（单行）（<strong>stretch（默认值）：</strong>物品在没有设置高度和宽度时，将会铺满整个交叉轴；<strong>flex-start：</strong>交叉轴的起点对齐；<strong>flex-end：</strong>交叉轴的终点对齐；<strong>center：</strong>交叉轴的居中点对齐；<strong>baseline: item：</strong> 的第一行文字的基线对齐）</li>
<li>flex-flow:复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li>
</ul>
<h2 id="4、BFC-是什么？"><a href="#4、BFC-是什么？" class="headerlink" title="4、BFC 是什么？"></a>4、BFC 是什么？</h2><blockquote>
<p>概念题，答题思路「是什么、怎么做、解决了什么问题、优点缺点怎么解决缺点」</p>
</blockquote>
<p>翻译,通过举例子回答,什么情况下会产生一个 BFC,千万不要尝试回答是什么 BFC</p>
<p><a href="./52664.html">博客链接</a></p>
<p>是什么：</p>
<ul>
<li>块级格式化上下文</li>
</ul>
<p>怎么做（触发条件）：</p>
<ul>
<li>浮动元素(元索的 float 不是 none)</li>
<li>绝对定位的元素(元素的 position 为 absolute 或 fixed)</li>
<li>行内块元素 inline- block</li>
<li>overflow: hidden, overflow 的值不为 visible 的块元素，只要不是 visible 默认值</li>
<li>弹性元素(display 为 flex 或 inline-flex 元素的直接子元素)</li>
</ul>
<p>解决了什么问题：</p>
<ul>
<li>清除浮动(为什么不用.clearfix 呢? )</li>
<li>防止 margin 合并(两个垂直方向的 div 的 margin 是会合并的，但是其中一个 div 成 BFC,就不会合</li>
</ul>
<p>BFC 全称是“块级格式化上下文”,如果给一个 div 写上 overflow: hidden,那么这个 div 里面的浮动元素就会被它包裹起来，这就是 BFC</p>
<h2 id="5、CSS-选择器优先级"><a href="#5、CSS-选择器优先级" class="headerlink" title="5、CSS 选择器优先级"></a>5、CSS 选择器优先级</h2><p><code>内联样式</code> &gt; <code>ID选择器</code> &gt; <code>类选择器</code> &gt; <code>标签选择器</code></p>
<ol>
<li>选择器越具体,优先级越高(比如: id 比 class 更高)</li>
<li>相同优先级，写在后面的，覆盖写在前面的</li>
<li>属性后面加!important 优先级最高，但是要少用</li>
</ol>
<h2 id="6、清除浮动"><a href="#6、清除浮动" class="headerlink" title="6、清除浮动"></a>6、清除浮动</h2><blockquote>
<p>背代码</p>
</blockquote>
<p>方法一：</p>
<p>给父元素加上.clearfix</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; <span class="comment">/* 或者 table */</span></span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 把这个 .clearfix 加载容器上，里面子元素的浮动就被清除了 */</span></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>给父元素加上 overflow：hidden;</p>
<h1 id="JavaScript-面试题"><a href="#JavaScript-面试题" class="headerlink" title="JavaScript 面试题"></a><strong>JavaScript 面试题</strong></h1><h2 id="1、数据类型有哪些"><a href="#1、数据类型有哪些" class="headerlink" title="1、数据类型有哪些"></a>1、数据类型有哪些</h2><blockquote>
<p>多背</p>
</blockquote>
<p>8 种数据类型，6 种是旧的，2 种是 ES6 新出的</p>
<ul>
<li>string 字符串</li>
<li>number 数字</li>
<li>boolean 布尔</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
<li>bigint （ES6）</li>
<li>symbol （ES6）</li>
</ul>
<p>拔高:</p>
<ol>
<li>什么时候用 null（<strong>作为函数的参数，表示该函数的参数不是对象，作为对象<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%9E%8B%E9%93%BE&spm=1001.2101.3001.7020">原型链</a>的终点</strong>）,什么时候用 undefined（<strong>变量被声明了，但没有赋值时，就等于 undefined；调用函数时，应该提供的参数没有提供，该参数等于 undefined；对象没有赋值的属性，该属性的值为 undefined；函数没有返回值时，默认返回 undefined</strong>）?</li>
<li>什么情况下用 bigint<ul>
<li>js 的 number 默认是”双精度浮点数”</li>
<li>bigint 当数字很大的时候，js 用 number 表示不了用 bigint</li>
<li>怎么用:在数字后面加 n（只能是整数，不能是小数）</li>
</ul>
</li>
</ol>
<h2 id="2、原型链"><a href="#2、原型链" class="headerlink" title="2、原型链"></a>2、原型链</h2><blockquote>
<p>大概念题，化成小概念，抽象化成具体(举例)</p>
</blockquote>
<h3 id="答题思路："><a href="#答题思路：" class="headerlink" title="答题思路："></a>答题思路：</h3><p><strong><em>哦，原型链涉及到的概念挺多的，我举例说明一下吧:</em></strong></p>
<p>假设我们有个普通对象 x&#x3D;{}，这个 x 会有一个隐藏属性, 这个隐藏属性会指向 Object.prototype,即:</p>
<ul>
<li>X._ <em>proto</em> &#x3D;&#x3D;&#x3D; Object.prototype</li>
<li>这个 x 的隐藏属性，等于 Object.prototype</li>
</ul>
<p><strong><em>此时，我们说的 x 的原型是 Object.prototype&#x2F;（Object.prototype 是 x 的原型）</em></strong></p>
<p>而这个* proto* 属性的唯一作用就是 来指向 x 的原型的</p>
<p><strong><em>说完了原型,我接下来说说原型链:</em></strong></p>
<p>假设我们有一个数组对象 a&#x3D;0，这个 a 也会有一个隐藏属性,这个隐藏属性会指向 Array.prototype,即:</p>
<ul>
<li>a._ proto_ &#x3D;&#x3D;&#x3D; Array.prototype</li>
<li>这个 a 的隐藏属性,等于 Array.prototype</li>
</ul>
<p><strong><em>这个时候，我们说 a 的原型是 Array.prototype, 跟上面的 x- -样。 仅有点不-样,那就是:</em></strong></p>
<p>Array.prototype 也有-个隐藏属性* proto* _, 指向 Object.prototype. 即:</p>
<ul>
<li>Array.prototype._ <em>proto</em> &#x3D;&#x3D;&#x3D; Object.prototype</li>
</ul>
<p>这样一来, a 就有两层原型:</p>
<ul>
<li>a 的原型是 Array.prototype</li>
<li>a 的原型的原型是 Object.prototype</li>
</ul>
<p>于是就通过隐藏属性* proto* 形成了一 个链条:</p>
<ul>
<li>a &#x3D;&#x3D;&#x3D;&gt; Array.prototype &#x3D;&#x3D;&#x3D;&gt; Object.prototype</li>
</ul>
<p><strong><em>这就是原型链</em></strong></p>
<h3 id="如何创建一个原型链："><a href="#如何创建一个原型链：" class="headerlink" title="如何创建一个原型链："></a>如何创建一个原型链：</h3><p>直接改,但是不推荐，可以用下面的方法：</p>
<ul>
<li><p>a &#x3D;Object.create(f) ES6 的方法</p>
</li>
<li><p>a&#x3D;newf（） ES5 的方法</p>
<p>​</p>
</li>
</ul>
<h3 id="原型链解决了什么问题"><a href="#原型链解决了什么问题" class="headerlink" title="原型链解决了什么问题:"></a>原型链解决了什么问题:</h3><p>在没有 Class 的情况下实现「继承」</p>
<p>以上面的例子为例:</p>
<ul>
<li>a 是 Array 的实例，a 拥有 Array.prototype 里的属性</li>
<li>Array 继承了 Object</li>
<li>a 是 Object 的间接实例，且拥有 Object,prototype 里的属性</li>
</ul>
<p>这样一来, a 就既拥有 Array.prototype 里的属性，又拥有 Object.prototype 的属性</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>简答，优雅，</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>跟 class 比，不支持私有属性</p>
<h3 id="怎么解决缺点："><a href="#怎么解决缺点：" class="headerlink" title="怎么解决缺点："></a>怎么解决缺点：</h3><p>使用 class，但 class 是 ES6 引入的，但是旧版本 IE 可能不支持</p>
<h2 id="3、this"><a href="#3、this" class="headerlink" title="3、this"></a>3、this</h2><blockquote>
<p>如果问这个函数里的 this 是什么，就是看这个函数是怎么调用的</p>
</blockquote>
<h3 id="方法一：转换代码"><a href="#方法一：转换代码" class="headerlink" title="方法一：转换代码"></a>方法一：转换代码</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23804247">this 转换代码</a></p>
<ul>
<li>用 call 调用函数，this 是 call 的第一个参数， 没有东西调用函数则是 undefined</li>
<li>undefined 自动变 window</li>
<li>如果题目绕来绕去，就看最后的一次调用</li>
<li>箭头函数没有 this,外面 this 是什么，这里的 this 就是什么</li>
</ul>
<p>箭头函数：</p>
<ul>
<li>箭头函数没有 this</li>
<li>箭头函数看到 this,就把 this 当做普通的变量用</li>
<li>往外看,外面没有就 undefined</li>
</ul>
<h3 id="方法二：背-this-指向"><a href="#方法二：背-this-指向" class="headerlink" title="方法二：背 this 指向"></a>方法二：背 this 指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title function_">fn</span>()</span><br><span class="line">  <span class="variable language_">this</span> =&gt; <span class="variable language_">window</span>	<span class="comment">// this 默认指向 window/global</span></span><br><span class="line"><span class="number">2.</span> obj.<span class="title function_">fn</span>()</span><br><span class="line">  <span class="variable language_">this</span> =&gt; obj	<span class="comment">// 对象调用，this 指向这个对象</span></span><br><span class="line"><span class="number">3.</span> fn.<span class="title function_">call</span>(xxx)</span><br><span class="line">  <span class="variable language_">this</span> =&gt; xxx	<span class="comment">// call 后面接一个东西，this 指向这个东西</span></span><br><span class="line"><span class="number">4.</span> fn.<span class="title function_">apply</span>(xxx)</span><br><span class="line">  <span class="variable language_">this</span> =&gt; xxx	<span class="comment">// apply 后面接一个东西，this 指向这个东西</span></span><br><span class="line"><span class="number">5.</span> fn.<span class="title function_">bind</span>(xxx)</span><br><span class="line">  <span class="variable language_">this</span> =&gt; xxx	<span class="comment">// bind 后面接一个东西，this 指向这个东西</span></span><br><span class="line"><span class="number">6.</span> <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">  <span class="variable language_">this</span> =&gt; 新的对象</span><br><span class="line"><span class="number">7.</span> fn = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span> =&gt; 外面的 <span class="variable language_">this</span> <span class="comment">// 外面 this 是什么，这里的 this 就是什么，外面的 this 根据前面6个判断</span></span><br><span class="line"><span class="number">8.</span> <span class="keyword">with</span>/<span class="variable language_">this</span>	<span class="comment">// 可能是 window，也可能是 global</span></span><br></pre></td></tr></table></figure>

<h2 id="4、new-做了什么"><a href="#4、new-做了什么" class="headerlink" title="4、new 做了什么"></a>4、new 做了什么</h2><blockquote>
<p>记忆题，写博客，甩链接</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23987456">JS 的 new 到底是干什么的？</a></p>
<p>推理：</p>
<ol>
<li>创建临时对象新对象</li>
<li>绑定原型</li>
<li>指定 this &#x3D;临时对象</li>
<li>执行构造函数</li>
<li>返回临时对象</li>
</ol>
<h2 id="5、call、apply、bind"><a href="#5、call、apply、bind" class="headerlink" title="5、call、apply、bind"></a>5、call、apply、bind</h2><p>都是用来调用函数</p>
<ul>
<li>call 和 apply 都是用来调用函数</li>
<li>call 只是调用</li>
<li>apply 会比 call 多一步:创建一 个数组</li>
</ul>
<p>一般情况下我们使用 call 就足够了，在下面这个情况就必须用 apply:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如一个参数是从文件里读出来的：</span></span><br><span class="line"><span class="keyword">var</span> a = readListFromFile <span class="comment">// 不管怎样它会得到一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么 a 最终可能为 a = [1, 2] 可能 [1, 2, 3] 也可能 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 不知道究竟是多少项</span></span><br><span class="line"><span class="comment">// 那如果要把 a 得到的所有数据，作为参数调用，那应该怎么做？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用 call：</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]...) <span class="comment">// 但是我不知道究竟是第几项结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以就用 apply：</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>, a) <span class="comment">// 那么 a 里的所有数据就会被调用了</span></span><br></pre></td></tr></table></figure>

<p>那用 apply 代替 call 行不行?理论上可以,但是 apply 比 call 多-步啊一创建数组</p>
<p>结论：没有特殊需求就用 call,不行就用 apply,比如数组</p>
<h2 id="6、立即执行函数"><a href="#6、立即执行函数" class="headerlink" title="6、立即执行函数"></a>6、立即执行函数</h2><blockquote>
<p>概念题，「是什么、怎么做、解决了什么问题、优点、缺点、怎么解决」</p>
</blockquote>
<p><a href="./52661.html">博客链接</a></p>
<h3 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h3><ul>
<li>声明一个匿名函数,然后立即执行</li>
<li>就种做法，就是立即执行函数</li>
</ul>
<p>注意:立即行函数，指的不是这个函数,而是声明一个函数在执行的这个过程动作叫立即执行函数</p>
<h3 id="怎么做："><a href="#怎么做：" class="headerlink" title="怎么做："></a>怎么做：</h3><p>在函数前面加感叹号，结尾加分号或者在函数前面加+ - ~ 都行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)()(</span><br><span class="line">  <span class="comment">// 用括号把整个表达式包起来</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)() <span class="comment">// 用括号把函数包起来</span></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)() + <span class="comment">// 取反，我不在意值是多少，我只想通过语法检查</span></span><br><span class="line">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">  &#125;)() -</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">~(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">void</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> a = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是匿名函数&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="解决了什么问题："><a href="#解决了什么问题：" class="headerlink" title="解决了什么问题："></a>解决了什么问题：</h3><p>是为了在 ES6 之前，创建-个「局部作用域」&#x2F;「局部变量」</p>
<p>ES6 可以这样创建局部变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>兼容性好，ES3 都支持</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>丑。我创建一个局部变量还要花里胡哨写这么一堆东西</p>
<h3 id="怎么解决："><a href="#怎么解决：" class="headerlink" title="怎么解决："></a>怎么解决：</h3><p>使用 block+let 语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  lat a = <span class="string">&#x27;我是局部变量&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)	<span class="comment">// 能读取 a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)	<span class="comment">// 不能读取 a</span></span><br></pre></td></tr></table></figure>

<h2 id="7、闭包"><a href="#7、闭包" class="headerlink" title="7、闭包"></a>7、闭包</h2><blockquote>
<p>阐述题，「是什么、 怎么做、解决了什么问题、优点缺点怎么解决缺点</p>
</blockquote>
<p><a href="./52662.html">博客链接</a></p>
<h3 id="是什么：-1"><a href="#是什么：-1" class="headerlink" title="是什么："></a>是什么：</h3><p>闭包是 JS 的一种**[语法特性]**</p>
<blockquote>
<p>一个函数访问了函数外的变量，就形成了闭包</p>
</blockquote>
<p>面试背：[怎么做]</p>
<h3 id="怎么做：-1"><a href="#怎么做：-1" class="headerlink" title="怎么做："></a>怎么做：</h3><ul>
<li>声明一个变量等于一个立即执行函数</li>
<li>然后立即执行函数里面声明一个变量 count</li>
<li>再声明一个函数对外面的 count 进行操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> count</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 访问了外部变量的函数</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决了什么问题：-1"><a href="#解决了什么问题：-1" class="headerlink" title="解决了什么问题："></a>解决了什么问题：</h3><ol>
<li>避免污染全局环境</li>
<li>提供对局部变量的间接访问</li>
<li>维持变量，使其不被垃圾回收</li>
</ol>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>简单，好用，不需要学习新知识，新语法</p>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><p>闭包**[使用不当]**可能造成内存泄漏</p>
<h3 id="怎么解决缺点：-1"><a href="#怎么解决缺点：-1" class="headerlink" title="怎么解决缺点："></a>怎么解决缺点：</h3><p>不用，少用，慎用</p>
<h2 id="8、如何实现类"><a href="#8、如何实现类" class="headerlink" title="8、如何实现类"></a>8、如何实现类</h2><blockquote>
<p>背代码，不要在意边边角角的东西</p>
</blockquote>
<p><a href="./52663.html">博客地址</a></p>
<h3 id="方法一：使用原型"><a href="#方法一：使用原型" class="headerlink" title="方法一：使用原型"></a>方法一：使用原型</h3><ul>
<li>把不可共享的东西放在函数里面</li>
<li>把共有属性写在原型上面</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">girlFriend</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eyeNumber</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">girlFriend.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`嘤嘤嘤~我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，我有<span class="subst">$&#123;<span class="variable language_">this</span>.eyeNumber&#125;</span>只眼睛`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> girlFriend1 = <span class="keyword">new</span> <span class="title function_">girlFriend</span>(<span class="string">&#x27;女友一号&#x27;</span>) <span class="comment">// girlFriend 函数就是一个类</span></span><br><span class="line">girlFriend1.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>5 6 7 这几行代码写在 girlFriend 函数外面是因为都一样的，所以写在原型里,写驻 girlFriend 函数里面的话,如果 new 几千万个 girlFriend,会很占内存</p>
</blockquote>
<h3 id="方法二：使用-class"><a href="#方法二：使用-class" class="headerlink" title="方法二：使用 class"></a>方法二：使用 class</h3><ul>
<li>把本身的属性写在 constructor 里面</li>
<li>把共有属性写在 constructor’外面</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">legsNumber</span> = <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`汪汪汪~ 我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>，我有<span class="subst">$&#123;<span class="variable language_">this</span>.legsNumber&#125;</span>条腿`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.legsNumber&#125;</span>条腿跑起来`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;旺财&#x27;</span>)</span><br><span class="line">dog1.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure>

<h2 id="9、如何实现继承"><a href="#9、如何实现继承" class="headerlink" title="9、如何实现继承"></a>9、如何实现继承</h2><p>类的继承(使用 extends 关键字)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y) <span class="comment">//调用了父类中的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">son.<span class="title function_">sum</span>()</span><br><span class="line">son1.<span class="title function_">sum</span>()</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//33</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 (借用构造函数法)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">son.<span class="title function_">sum</span>()</span><br><span class="line">son1.<span class="title function_">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//33</span></span><br></pre></td></tr></table></figure>

<h2 id="10、手写：节流、防抖"><a href="#10、手写：节流、防抖" class="headerlink" title="10、手写：节流、防抖"></a>10、手写：节流、防抖</h2><blockquote>
<p>背代码，甩博客</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7070506876646981646/">博客链接</a></p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>单位时间内，频繁触发一个事件，以最后一次触发为准。<br>防抖的实现： 1.声明一个全部变量存储定时器 ID。 2.每一次触发交互的时候，先清除上一次的定时器，然后开启本次定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入框事件</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//1先清除之前的定时器</span></span><br><span class="line">  <span class="built_in">clearTimeout</span>(timeID)</span><br><span class="line">  <span class="comment">//2.开启本次定时器</span></span><br><span class="line">  timeID = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`发送ajax,搜索的内容是<span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>单位时间内，频繁触发一个事件，只会触发一次。<br>节流的实现： 1.声明一个全局变量存储触发事件。 2.每一次触发事件，获取当前时间。 3.判断当前时间与上一次触发事件，是否超过了间隔。 4.如果超过间隔时间，则执行事件处理代码，然后存储本次触发的时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个全局变量存储触发时间</span></span><br><span class="line"><span class="keyword">let</span> lastTime = <span class="literal">null</span></span><br><span class="line"><span class="comment">//页面滚动事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//1.每一次触发 先获取本次时间戳</span></span><br><span class="line">  <span class="keyword">let</span> currentTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="comment">//2.判断当前时间 与 上次触发时间 是否超过间隔</span></span><br><span class="line">  <span class="keyword">if</span> (currentTime - lastTime &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>) <span class="comment">//获取滚动距离</span></span><br><span class="line">    <span class="comment">//3.存储本次的触发时间</span></span><br><span class="line">    lastTime = currentTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>总结<br>函数防抖：<br>将几次操作合并为一次操作进行。原理是维护一个定时器，规定在延迟时间后触发函数，只有最后一次操作能被触发。<br>函数节流：<br>使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>**防抖:**search 联想搜索，用户在不断输入内容的时候，用防抖来节约请求资源。window 触发 resize 时候，不断调整浏览器窗口大小会不断的触发这个事件，用防抖让其只触发一次。<br><strong>节流：</strong>鼠标不断点击（mousedown）触发，让其单位时间内只触发一次。（监听滚动事件，滑到底部自动加载更多。）</p>
<h2 id="11、手写：发布订阅"><a href="#11、手写：发布订阅" class="headerlink" title="11、手写：发布订阅"></a>11、手写：发布订阅</h2><p>发布订阅，这是一个著名的设计模式</p>
<p>设计模式在前端中是几乎不太重要的,设计模式的前提是:你学会面向对象</p>
<p>JS 的的面向对象，基本没人用，例如继承</p>
<p>JS 是往函数式方向、数据响应式方向走，JS 的面向对象,基本废掉</p>
<p>什么是发布订阅模式?</p>
<p>就是一个对象能够发布一个事件,然后你能订阅这个事件，这就叫发布订阅模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventHub = &#123;</span><br><span class="line">  <span class="attr">map</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">on</span>: <span class="function">(<span class="params">name, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    eventHub.<span class="property">map</span>[name] = eventHub.<span class="property">map</span>[name] || []</span><br><span class="line">    eventHub.<span class="property">map</span>[name].<span class="title function_">push</span>(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">emit</span>: <span class="function">(<span class="params">name, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> q = eventHub.<span class="property">map</span>[name]</span><br><span class="line">    <span class="keyword">if</span> (!q) <span class="keyword">return</span></span><br><span class="line">    q.<span class="title function_">map</span>(<span class="function">(<span class="params">f</span>) =&gt;</span> f.<span class="title function_">call</span>(<span class="literal">null</span>, data))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">off</span>: <span class="function">(<span class="params">name, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> q = eventHub.<span class="property">map</span>[name]</span><br><span class="line">    <span class="keyword">if</span> (!q) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> index = q.<span class="title function_">indexOf</span>(fn)</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">eventHub.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">eventHub.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">console</span>.<span class="property">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  eventHub.<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>也可以用 class 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventHub</span> &#123;</span><br><span class="line">  map = &#123;&#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>[name] = <span class="variable language_">this</span>.<span class="property">map</span>[name] || []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>[name].<span class="title function_">push</span>(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">name, data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fnList = <span class="variable language_">this</span>.<span class="property">map</span>[name] || []</span><br><span class="line">    fnList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, data))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fnList = <span class="variable language_">this</span>.<span class="property">map</span>[name] || []</span><br><span class="line">    <span class="keyword">const</span> index = fnList.<span class="title function_">indexOf</span>(fn)</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    fnList.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">EventHub</span>()</span><br><span class="line">e.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi &#x27;</span> + name)</span><br><span class="line">&#125;)</span><br><span class="line">e.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + name)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="12、手写：AJAX"><a href="#12、手写：AJAX" class="headerlink" title="12、手写：AJAX"></a>12、手写：AJAX</h2><blockquote>
<p>背代码</p>
</blockquote>
<h3 id="简易版："><a href="#简易版：" class="headerlink" title="简易版："></a>简易版：</h3><ul>
<li>第一句:明一个对象，-般叫 xhr</li>
<li>第二句:设置发请求发到哪</li>
<li>第三句:发送消息体</li>
<li>第四句:请求成功之后要有个回调</li>
<li>如果想返回失败的回调，那就补充 onerror()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/xxx&#x27;</span>)</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;得到内容&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>

<h3 id="完整版："><a href="#完整版：" class="headerlink" title="完整版："></a>完整版：</h3><p>readyState 属性返回一个 XMLHttpRequest 代理当前所处的状态</p>
<ol>
<li>代理被创建， 但还没调用 open()</li>
<li>open0 已被调用</li>
<li>send()已被调用(并且头部和状态已经可以获得)</li>
<li>下载中</li>
<li>下载已完成</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/xxx&#x27;</span>)</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>

<h2 id="13、手写：简化版-Promise"><a href="#13、手写：简化版-Promise" class="headerlink" title="13、手写：简化版 Promise"></a>13、手写：简化版 Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (操作成功) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>class 写法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 Promise 的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executer</span>) &#123;</span><br><span class="line">    <span class="comment">//构造函数 constructor 里面是个执行器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;pending&#x27;</span> <span class="comment">//默认的状态 pending</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span> <span class="comment">//成功的值默认 undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span> <span class="comment">//失败的值默认 undefined</span></span><br><span class="line">    <span class="comment">//状态只有在 pending 时候才能改变</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolveFn</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//判断只有等待时才能 resolve 成功</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == pending) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;resolve&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断只有等待时才能 reject 失败</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">rejectFn</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == pending) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;reject&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//把 resolve 和 reject 两个函数传给执行器 executer</span></span><br><span class="line">      <span class="title function_">executer</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e) <span class="comment">//失败的话进 catch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFufilled, onReject</span>) &#123;</span><br><span class="line">    <span class="comment">//如果状态成功调用 onFufilled</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;resolve&#x27;</span>)) &#123;</span><br><span class="line">      <span class="title function_">onFufilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果状态失败调用 onReject</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;reject&#x27;</span>)) &#123;</span><br><span class="line">      <span class="title function_">onReject</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、手写：Promise-all-未解决"><a href="#14、手写：Promise-all-未解决" class="headerlink" title="14、手写：Promise.all (未解决)"></a>14、手写：Promise.all (未解决)</h2><h2 id="15、手写：深拷贝"><a href="#15、手写：深拷贝" class="headerlink" title="15、手写：深拷贝"></a>15、手写：深拷贝</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_59519449/article/details/123582770">浅拷贝和深拷贝的区分</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7070916194575843341/">博客链接</a></p>
<p>代码不需要全背下来，但要有一下关键点</p>
<blockquote>
<p>先 JSON.stringify，然后 JSON.parse 得到一个新的对象</p>
</blockquote>
<h3 id="方法一：用-JSON"><a href="#方法一：用-JSON" class="headerlink" title="方法一：用 JSON"></a>方法一：用 JSON</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a))</span><br></pre></td></tr></table></figure>

<p><strong>答题要点，指出这个方法有以下缺点：</strong></p>
<ol>
<li>不支持 Date、正则、undefined、 函数等数据</li>
<li>不支持引用(即环状结构)</li>
<li>我还会第二种方法,使用递归</li>
</ol>
<h3 id="方法二：用递归"><a href="#方法二：用递归" class="headerlink" title="方法二：用递归"></a>方法二：用递归</h3><p><strong>关键点：</strong></p>
<blockquote>
<p>说出前 3，4 点就够了</p>
</blockquote>
<ol>
<li>递归 <br>a.深拷贝构造出新对象后,再用循环调用深拷贝(自己调用自己就是递归)</li>
<li>判断数据类型</li>
<li>检查循环引用<br>a.检查”环”，因为可能会在递归里出不来，需要用一个 Map 来映射:只要我曾经拷贝过了，我就不会再拷贝第二次。</li>
<li>不拷贝原型上的属性<br>a.会占内存，使用 hasOwnProperty 来过滤</li>
<li>缓存不能放在全局变量，不然缓存会越来越多,很占内存<br>a.最好临时创建并递归传递:在调用深拷贝时，首先判断是否存在 cache,如果不存在,就创建 cache &#x3D; new Map<br>b.然后在递归的时候，传到调用的深拷贝的参数</li>
</ol>
<h2 id="16、数组去重"><a href="#16、数组去重" class="headerlink" title="16、数组去重"></a>16、数组去重</h2><blockquote>
<p>搜博客，背代码，发博客</p>
</blockquote>
<p>三种方案：</p>
<ol>
<li><strong>使用 Set</strong><br>a.把一个数组放在 Set 里面，就会变成一个没有重复元素的集合<br>b.然后把这个集合变成数组，就会变成没有重复元素的数组<br>c. Array.from(new Set()<br>d.面试已经禁用这种，因为太简单了</li>
<li><strong>使用计数排序的思路</strong><br>a.缺点:只支持字符串</li>
<li><strong>使用 Map</strong><br>a.缺点：兼容性差了一点</li>
</ol>
<p><strong>使用 Set</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniq = <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(a)) <span class="comment">// new Set 会接受一个数组，会自动地把重复项去掉，但 new Set 不是个数组，是一个集合，然后使用 Array.from，就可以把一个集合变成数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用计数排序的思路</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniq = <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> number = a[i]</span><br><span class="line">    <span class="keyword">if</span> (number === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (number <span class="keyword">in</span> map) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    map[number] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缺点：只能把数字变成字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 Map</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniq = <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> number = a[i]</span><br><span class="line">    <span class="keyword">if</span> (number === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(number)) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(number, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...map.<span class="title function_">keys</span>()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17、放弃题：-x3D-x3D-相关的题"><a href="#17、放弃题：-x3D-x3D-相关的题" class="headerlink" title="17、放弃题：&#x3D;&#x3D; 相关的题"></a>17、放弃题：&#x3D;&#x3D; 相关的题</h2><blockquote>
<p>反着答</p>
</blockquote>
<p>我从来不用两个等于号&#x3D;&#x3D;,因为太难记了，我只用三个等于号&#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;是一个很难用的符号，非常非常容易出错</p>
<h2 id="18、不用-class-如何实现继承？用-class-又如何实现继承？"><a href="#18、不用-class-如何实现继承？用-class-又如何实现继承？" class="headerlink" title="18、不用 class 如何实现继承？用 class 又如何实现继承？"></a>18、不用 class 如何实现继承？用 class 又如何实现继承？</h2><blockquote>
<p>背代码</p>
</blockquote>
<p><strong>不用 class</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span> <span class="comment">// Animal 有个属性 a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="comment">// 有个原型方法叫 move</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Dog 继承这个 Animal</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// 调用 Animal，arguments 可以不写</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">d</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">f.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 实现原型的继承</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">f</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用 class**</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// extends</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>() <span class="comment">// 在 constructor 调用 super</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19、正则实现-trim"><a href="#19、正则实现-trim" class="headerlink" title="19、正则实现 trim()"></a>19、正则实现 trim()</h2><blockquote>
<p>背代码，学正则</p>
</blockquote>
<p>把前后空格去掉，把它们全部变成空字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trim</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> string.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20、async-x2F-await，如何捕获异常"><a href="#20、async-x2F-await，如何捕获异常" class="headerlink" title="20、async&#x2F;await，如何捕获异常"></a>20、async&#x2F;await，如何捕获异常</h2><blockquote>
<p>看 MDN，举例，写博客</p>
</blockquote>
<p>获取异常的方法有两种：.then().catch() ，try&#x2F;catch</p>
<p>.catch()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">gettest</span>()<span class="keyword">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取失败&#x27;</span>+err)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try&#x2F;catch 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">gettest</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取成功&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取失败&#x27;</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21、JSONP、CORS、跨域"><a href="#21、JSONP、CORS、跨域" class="headerlink" title="21、JSONP、CORS、跨域"></a>21、JSONP、CORS、跨域</h2><blockquote>
<p>比较难，多花时间，举例，写博客</p>
</blockquote>
<p><strong>什么是跨域</strong><br>指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站</p>
<p>比如一个黑客,他利用 iframe 把真正的银行登录页面嵌到他的页面上,当你使用真实的用户名和密码登录时,如果没有同源限制,他的页面就可以通过 JavaScript 读取到你的表单中输入的内容,这样用户名和密码就轻松到手了。</p>
<p>解决方式<br><strong>1、jsonp</strong><br>原理：动态创建一个 script 标签。利用 script 标签的 src 属性不受同源策略限制。因为所有<br>的 src 属性和 href 属性都不受同源策略限制。可以请求第三方服务器数据内容。<br>步骤<br>1.1）去创建一个 script 标签<br>1.2）script 的 src 属性设置接口地址<br>1.3）接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。<br>1.4）通过定义函数名去接收后台返回数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去创建一个 script 标签</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); <span class="comment">//script 的 src 属性设置接口地址 并带一个 callback 回调函数名称</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;HTTP://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>; <span class="comment">//插入到页面</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script); <span class="comment">//通过定义函数名去接收后台返回数据 function jsonpCallback(data)&#123;</span></span><br><span class="line"><span class="comment">//注意 jsonp 返回的数据是 json 对象可以直接使用</span></span><br><span class="line"><span class="comment">//Ajax 取得数据是 json 字符串需要转换成 json 对象才可以使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、 CORS：跨域资源共享</strong><br>原理：服务器设置 Access-Control-Allow-OriginHTTP 响应头之后，浏览器将会允许跨域请求<br>限制：浏览器需要支持 HTML5，可以支持 POST，PUT 等方法兼容 ie9 以上需要后台设置<br>Access-Control-Allow-Origin: * &#x2F;&#x2F;允许所有域名访问，或者<br>Access-Control-Allow-Origin: HTTP:&#x2F;&#x2F;a.com &#x2F;&#x2F;只允许所有域名访问</p>
<p>(3、反向代理<br>4、window+iframe) 可以不记</p>
<h2 id="22、Promise、Promise-all、Promise-race-分别怎么用-未解决"><a href="#22、Promise、Promise-all、Promise-race-分别怎么用-未解决" class="headerlink" title="22、Promise、Promise.all、Promise.race 分别怎么用 (未解决)"></a>22、Promise、Promise.all、Promise.race 分别怎么用 (未解决)</h2><blockquote>
<p>举例，写博客</p>
</blockquote>
<h2 id="23、ES6-语法有哪些，分别是什么"><a href="#23、ES6-语法有哪些，分别是什么" class="headerlink" title="23、ES6 语法有哪些，分别是什么"></a>23、ES6 语法有哪些，分别是什么</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7057806756348428295">博客链接</a></p>
<p>class 和 Promise 一定会问</p>
<p>举例（let，const，class），甩链接</p>
<h1 id="DOM-面试题"><a href="#DOM-面试题" class="headerlink" title="DOM 面试题"></a><strong>DOM 面试题</strong></h1><h2 id="1、DOM-事件模型"><a href="#1、DOM-事件模型" class="headerlink" title="1、DOM 事件模型"></a>1、DOM 事件模型</h2><blockquote>
<p>记忆题</p>
</blockquote>
<p>简述：DOM 事件模型</p>
<ul>
<li>每一个事件都会经历先从上到下的捕获阶段,再经历从下到上的冒泡阶段</li>
<li>如何选择捕获或冒泡:在添加事件监听的时候[ addEventListener(“click’, fn, true&#x2F;false)」 ，第三个参数如果传 true 则是捕获阶段,传 false 或者不传，则是冒泡阶段</li>
<li>如果希望在某个阶段停止传播:可以使用 I event.stopPropagation0」 来阻止捕获或冒泡</li>
</ul>
<h2 id="2、事件委托"><a href="#2、事件委托" class="headerlink" title="2、事件委托"></a>2、事件委托</h2><blockquote>
<p>记忆题</p>
</blockquote>
<p>「target」VS「currentTarget」 :</p>
<ul>
<li>currentTarget 是监听的对象，比如我监听的是 ul, 那么这个 currentTarget, 就是 ul</li>
<li>target 是触发的对象，比如我监听 ul, 然后户点击的是 span, 那么 target 就是 span</li>
</ul>
<h3 id="错误版（但可以过）："><a href="#错误版（但可以过）：" class="headerlink" title="错误版（但可以过）："></a>错误版（但可以过）：</h3><ul>
<li>监听一个事件,比如监听列表的 click 事件</li>
<li>当用户点击时，我们看他点击的目标的标签名小写之后是不是等于 li,如果是 li,就说说明用户点了了列表中的某-项,那么我就执行某个函数</li>
<li>就是我不直接监听 li,而是监听 li 的父元素,比如 ul,如果点击任何一个 li,都会触发这个函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">fn</span>() <span class="comment">// 执行某个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>错误在于:如果户点的不是 li,是 li 里面的 span,就没法触发这个函数</p>
<p>但一定要说还知道下面一种</p>
<h3 id="高级版（不用背）："><a href="#高级版（不用背）：" class="headerlink" title="高级版（不用背）："></a>高级版（不用背）：</h3><p>思路:</p>
<ul>
<li>点击 span 之后，要看它的父元素是不是 li, 如果父元素不是 li, 那就看元素的父元素是不是 li</li>
<li>只要它的祖先元素中有一个是 li, 就说明点击了 li</li>
<li>一直看到 ul 为止,如果到了 ul 还没有 li, 那么就证明点击到了外面的 li</li>
</ul>
<p>代码思路：</p>
<ul>
<li>写一个“委托”函数 delegate, 接受:素,事件类型,选择的元素，执行的函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delegate</span>(<span class="params">element, eventType, selector, fn</span>) &#123;</span><br><span class="line">  element.<span class="title function_">addEventListener</span>(eventType, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> el = e.<span class="property">target</span></span><br><span class="line">    <span class="keyword">while</span> (!el.<span class="title function_">matches</span>(selector)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element === el) &#123;</span><br><span class="line">        el = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      el = el.<span class="property">parentNode</span></span><br><span class="line">    &#125;</span><br><span class="line">    el &amp;&amp; fn.<span class="title function_">call</span>(el, e, el)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>节省监听器(如果我有 100 个列表,我不用事件委托的话,就需要写 100 adeventistener)</li>
<li>可以动态监听(如果 ul 里是空的，我只能添加到 ul 上,以后在 ul 里添加 i,点击的时候依然可以触发 u 的监听器)</li>
</ul>
<h3 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>调试复杂，不容易确定监听者（在调试的时候，无法发现当前的元素有哪些时间监听）</li>
</ul>
<h3 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h3><ul>
<li>没有解决方法</li>
<li>但是可以缓解：一些浏览器的开发者工具里，有[Event Listeners] ，可以查看哪句代码在监听</li>
<li>但是由于是父元素在监听，所有还是不清楚究竟是在监听哪个</li>
</ul>
<h2 id="3、用-mouse-事件写一个可拖拽的-div"><a href="#3、用-mouse-事件写一个可拖拽的-div" class="headerlink" title="3、用 mouse 事件写一个可拖拽的 div"></a>3、用 mouse 事件写一个可拖拽的 div</h2><p><strong>易错点：</strong></p>
<ol>
<li>px 需要去掉</li>
<li>监听的不是元素，是 document 的</li>
<li>如果想要更高性能，则把 left 和 right 改为 transform：transalteX&#x2F;Y</li>
</ol>
<p><strong>思路：</strong></p>
<ol>
<li>声明变量 dragging:否被拖拽，默认为 false</li>
<li>声明变量 position:坐标，默认为 null</li>
<li>监听鼠标按下事件「mousedown」 ，按下则把 dragging 为 true (鼠标按下的时候把位置记下来)</li>
<li>监听鼠标移动，判断是否在拖动，然后获取鼠标坐标，监听的是 document,监听 div 的话，当移动快了鼠标</li>
<li>移除 div 之后，会有无法移动的情况(当移动鼠标的时候需要记录鼠标的位置, x 和 y)</li>
<li>获取按下鼠标时的坐标，细节: left 和 top 是有 px 的，px 后面不能加数字，需要 parseInt, 而且-开始 left</li>
<li>和 top 可能是空的，所以需要给它初始值 0</li>
<li>计算鼠标移动了多少(我要知道和上次坐标的差值)</li>
<li>把位移写在 div.上面: div 的坐标加上位移</li>
<li>把拖动后的坐标写给下一次鼠标按下的开始(松开鼠标手,当前坐标设置为下一次鼠标按下的基准点)</li>
<li>监听鼠标松开事件，则无法移动:把 dragging 设置为 false (没有移动就别拖)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragging = <span class="literal">false</span> <span class="comment">// 声明变量 拖拽，默认 false</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="literal">null</span> <span class="comment">// 声明变量 坐标，默认 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听鼠标被按下</span></span><br><span class="line">xxx.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  dragging = <span class="literal">true</span> <span class="comment">// 如果被按下，变为 true</span></span><br><span class="line">  position = [e.<span class="property">clientX</span>, e.<span class="property">clientY</span>] <span class="comment">// 获取按下鼠标时的坐标</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听鼠标移动</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取鼠标的坐标</span></span><br><span class="line">  <span class="keyword">if</span> (dragging === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> x = e.<span class="property">clientX</span></span><br><span class="line">  <span class="keyword">const</span> y = e.<span class="property">clientY</span></span><br><span class="line">  <span class="keyword">const</span> deltaX = x - position[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> deltaY = y - position[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> left = <span class="built_in">parseInt</span>(xxx.<span class="property">style</span>.<span class="property">left</span> || <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> top = <span class="built_in">parseInt</span>(xxx.<span class="property">style</span>.<span class="property">top</span> || <span class="number">0</span>)</span><br><span class="line">  xxx.<span class="property">style</span>.<span class="property">left</span> = left + deltaX + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  xxx.<span class="property">style</span>.<span class="property">top</span> = top + deltaY + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  position = [x, y]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  dragging = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-面试题"><a href="#HTTP-面试题" class="headerlink" title="HTTP 面试题"></a>HTTP 面试题</h1><h2 id="1、GET-和-POST-区别"><a href="#1、GET-和-POST-区别" class="headerlink" title="1、GET 和 POST 区别"></a>1、GET 和 POST 区别</h2><blockquote>
<p>记忆题，背</p>
</blockquote>
<p>区别在于 GET 是[读]，post 是[写]，post 联想支付宝付款</p>
<h3 id="区别一：幂等性"><a href="#区别一：幂等性" class="headerlink" title="区别一：幂等性"></a>区别一：幂等性</h3><blockquote>
<p>一个操作如果重复做很多遍，并不改变结果，就是幂等的[重复不影响结果]</p>
</blockquote>
<ol>
<li>GET「幂等」，POST「不幂等」</li>
<li>根本原因 GET 是「读」，POST 是[写」</li>
<li>用浏览器打开网页会发送 GET 请求,想要 POST 打开网页要用 form 标签</li>
<li>GET 拼的页面刷新是无害的，POST 打开的页面刷新需要确认</li>
<li>GET 结果会被缓存, POST 结果不会被缓存</li>
<li>GET 打开的页面可被书签收藏，POST 打开的页面不能被书签收藏(浏览器的功能)</li>
</ol>
<h3 id="区别二：请求参数"><a href="#区别二：请求参数" class="headerlink" title="区别二：请求参数"></a>区别二：请求参数</h3><ol>
<li>通常，GET 请求参数放在 url 里，POST 请求数据放在 body (消息体)里。(这里注意 老师的讲解)</li>
<li>GET 比 POST 不安全,因为参数直接暴露在 URL 上,所以不能用来传递敏感信息。(xjb 扯)</li>
<li>GET 请求参数放在 url 里是有长度限制的，而 POST 放在 body 里没有长度限制。(xjb 扯)</li>
</ol>
<h3 id="区别三：TCP-packet"><a href="#区别三：TCP-packet" class="headerlink" title="区别三：TCP packet"></a>区别三：TCP packet</h3><ol>
<li>GET 产生一个 TCP 数据包；POST 产生两个或以上 TCP 包</li>
</ol>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>以上是实践过程中二者的区别，根据技术规格文档，GET 和 POST 的最大区别是语义<br>GET 是获取数据，POST 是提交数据</p>
<h2 id="2、HTTP-缓存"><a href="#2、HTTP-缓存" class="headerlink" title="2、HTTP 缓存"></a>2、HTTP 缓存</h2><blockquote>
<p>搜博客</p>
</blockquote>
<p>ETag: 一般是 MD5</p>
<p>Expire:日期.</p>
<p>Cache-Control:常见 max age &#x3D; 600 (600 是秒)</p>
<p>强缓存一缓存: Cache- Control. Expires. Etag</p>
<p>弱缓存一内容协商: If-None -Match. I-Mdifed-since</p>
<table>
<thead>
<tr>
<th></th>
<th>缓存（强缓存）</th>
<th>内容协商（弱缓存）</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP 1.1</td>
<td>Cache-Control: max-age&#x3D; 3600<br>Etag: ABC</td>
<td>If-None-Match: ABC 响应状态码:<br>304 或者 200</td>
</tr>
<tr>
<td>HTTP 1.0</td>
<td>Expires: Wed, 21 Oct 2015<br>02:30:00 GMT L ast- Modified:<br>Wed, 21 Oct 2015 01:00:00 GMT</td>
<td>If-Modified-Since: Wed, 21 Oct<br>2015 01:00:00 GMT 响应状态码:<br>304 或 200</td>
</tr>
</tbody></table>
<p>面试官可能会问到 Pragma,但 MDN 已经明确不推荐使用它。所以我就没有了解了</p>
<h3 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h3><p><strong>Expire 和 Cache-Control 区别</strong></p>
<ul>
<li>Expire 是在某个时间过期，但是有 bug<br>·因为「本地时间」可以被用户修改的</li>
<li>Cache-Control 的 max-age 多少秒后过期<br>·max-age 是相对日期，不容易出 BUG</li>
</ul>
<p><strong>ETag 和 Cache-Control 区别</strong></p>
<ul>
<li>ETag 有请求<br>·有请求的状态码是 304</li>
<li>Cache-Control 无请求(本地读缓存)</li>
</ul>
<p><strong>PWA 缓存顺序</strong></p>
<h2 id="3、HTTP-和-HTTPS-的区别有哪些？"><a href="#3、HTTP-和-HTTPS-的区别有哪些？" class="headerlink" title="3、HTTP 和 HTTPS 的区别有哪些？"></a>3、HTTP 和 HTTPS 的区别有哪些？</h2><p>简单来说，HTTPS 就是 HTTP 加上一个安全层</p>
<blockquote>
<p>HTTPS &#x3D; HTTP + SSL&#x2F;TLS (安全层)</p>
</blockquote>
<h3 id="区别列表："><a href="#区别列表：" class="headerlink" title="区别列表："></a>区别列表：</h3><ol>
<li>HTTP 是明文传输的，不安全; HTTPS 是加密传输的，非常安全</li>
<li>HTTP 使用 80 端口，HTTPS 使用 443 端口</li>
<li>HTTP 较快，HTTPS 较慢</li>
<li>HTTPS 的证书一般需要购买(也有免费的)，HTTP 不需要证书</li>
</ol>
<h2 id="4、TCP-三次握手四次挥手"><a href="#4、TCP-三次握手四次挥手" class="headerlink" title="4、TCP 三次握手四次挥手"></a>4、TCP 三次握手四次挥手</h2><blockquote>
<p>记忆题</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<p>建立 TCP 连接时，服务器（server）与客户端（client）会经历的过程</p>
</blockquote>
<p>三次握手是为了保证建立起一个安全，可靠的连接</p>
<ol>
<li>服务器属于关闭状态，客户端主动向服务器发送-个报文(SYN), 想与服务端建立起一个新的连接, 并诅等待服务器确认。</li>
<li>服务器接收户端发来的报文,确认客户端的报文,并且把消息确认包发送给客户端，但是服务端此时不知道服务端向客户端发送的消息能不能收到。</li>
<li>客户端收到消息确认包之后，需要继续给服务端一个消息包， 組建立起连接。</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote>
<p>关闭 TCP 连接时，服务器（server）与客户端（client）会经历的过程</p>
</blockquote>
<ol>
<li>客户端想要与服务端断开连接,客户端向服务端发送一个报文， 表示想要与服务端断开连接。</li>
<li>服务端收到报文之后，知道客户端想要与客户端断开连接,但是此时服务端可能还有剩下的一些数据没有传输，服务端向客户端发送确认消息包，告诉客户端已确认但是还有剩下的数据没传完，我传完之后再告诉你。</li>
<li>服务端做好与客户端的准备之后，服务端发送- -个断开连接的报文给客户端,表示服务端已经做好断开链接的准备</li>
<li>客户端收到服务端发来的报文之后，需要发送一个消息确认的报文给服务端。</li>
</ol>
<p>四次挥手是为了确保连接的安全的断开。</p>
<h3 id="TCP-是什么"><a href="#TCP-是什么" class="headerlink" title="TCP 是什么"></a>TCP 是什么</h3><ul>
<li>全称是:传输内容协议</li>
<li>TCP 属于传输层，HTTP 属于应用层</li>
<li>传输层建立端到端的链接</li>
<li>例如:我访问 baidu.com, TCP 就是模拟了我和 baidu.com 之间的车道,这个车道可以传输数据</li>
</ul>
<h2 id="5、同源策略-与-跨域"><a href="#5、同源策略-与-跨域" class="headerlink" title="5、同源策略 与 跨域"></a>5、同源策略 与 跨域</h2><blockquote>
<p>论述题，告诉面试官什么是[同源]，什么是[跨域]</p>
</blockquote>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p><strong>是什么：</strong></p>
<p>如果两个 URL 的<strong>协议、端口、和域名</strong>都完全一致的话， 则这两个 URL 是同源的。</p>
<p>注意：</p>
<ul>
<li>HTTP 默认端口: 80</li>
<li>HTTPS 默认端口: 443</li>
</ul>
<p><strong>怎么做：</strong></p>
<p>只要在<strong>浏览器</strong>打开顸面，就默认遵守同源策略</p>
<p><strong>优点：</strong></p>
<p>保护用户的<strong>隐私安全</strong>和<strong>数据安全</strong></p>
<p><strong>缺点：</strong></p>
<p>很多时候，前端需要访问另-个域名的后端接口, 会被浏览器阻止其获取响应(请求会发出,但是响应回不来)</p>
<p>比如: A 站点访问 B 站点的&#x2F;money 查询余额接口,请求会发出,但是响应会被浏览器屏蔽</p>
<p><strong>怎么解决：</strong></p>
<p>使用<strong>跨域</strong>手段</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><strong>JSONP</strong></p>
<p><strong>做法：</strong></p>
<ol>
<li><strong>A 站</strong>点利用 scrip 标签可以跨域的特性，向<strong>B 站点</strong>发送 get 请求。</li>
<li>**<em>B 站点后端</em>**改造 JS 文件的内容，将数据传进回调函数。</li>
<li><strong>A 站点</strong>通过回调函数拿到<strong>B 站点</strong>的数据。</li>
</ol>
<p><strong>优点：</strong></p>
<p>改动小，不需要什么大的变化</p>
<p><strong>缺点：</strong></p>
<ol>
<li>JSONP 的缺点是:没有用户认证功能，后端改了之后,所有人都可以访问这个数据<br>a.解决方法:需要在 JSONP 加上 Token</li>
<li>不支持 POST, JSONP 只能发送 GET 请求</li>
</ol>
<p><strong>CORS</strong></p>
<blockquote>
<p>跨域名资源分享方案</p>
</blockquote>
<p><strong>做法：</strong></p>
<ul>
<li>对于简单的请求(简单请求只能 GET) :在被请求的站点响应头添加:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//发请求的站点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于复杂请求:如 PATCH,被请求的站点需要:响应 OPTIONS 请求,在响应中添加如下的响应头</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">https</span>:<span class="comment">//发请求的站点</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">POST</span>, <span class="variable constant_">GET</span>, <span class="variable constant_">OPTIONS</span>, <span class="variable constant_">PATCH</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: <span class="title class_">Content</span>-<span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要附带身份信息, JS 中需要在 AJAX 里设置 xhr.withCredentials &#x3D; true</li>
<li>Nginx 代理&#x2F; Node.js 代理<br>·前端请求到后端，后端请求到另一个域名的后端<br>·前端-&gt;后端-&gt;另-个域名的后端</li>
</ul>
<p>详情搜索 MDN CORS</p>
<h2 id="6、Session、Cookie、LocalStorage、SessionStorage-的区别"><a href="#6、Session、Cookie、LocalStorage、SessionStorage-的区别" class="headerlink" title="6、Session、Cookie、LocalStorage、SessionStorage 的区别"></a>6、Session、Cookie、LocalStorage、SessionStorage 的区别</h2><blockquote>
<p>纯记忆题，多看，写博客</p>
</blockquote>
<p><strong>是什么：</strong></p>
<p><strong>Session：</strong>一段时间内的[会话]。</p>
<p><strong>Cookie：</strong>服务器发给浏览器的一段字段（票），浏览器在每次访问服务器的时候，都要把这段字段（票）带上去-带门票。</p>
<p><strong>LocalStorage：</strong>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<p><strong>SessionStorage：</strong>用于临时保存同一窗口的数据，关闭窗口后 sessionStorage 的数据将会不存在，它是以 key value 键值对的形式储存。</p>
<p><strong>Cookie V.S. LocalStorage</strong></p>
<ul>
<li>Cookie 大小限制一般是 4K, LocalStorage 大小限制 5M</li>
<li>Cookie 用来存户信息，LocalStorage 来存不重要的数据的</li>
<li>Cookie 会发送到服务器里，LocalStorage 不发送到服务器里</li>
</ul>
<p><strong>LocalStorage V.S. SessionStorage</strong></p>
<ul>
<li>LocalStorage 不会自动过期</li>
<li>SessionStorage 会在会话结束的时候过期</li>
</ul>
<p><strong>Cookie V.S. Session</strong></p>
<ul>
<li>Session 一般是在服务器的文件里</li>
<li>Cookie -般是在浏览器的文件里</li>
<li>Session -般是基于 Cookie 来实现的(把 Session ID 放到 Cookie 面)</li>
</ul>
<h2 id="7、HTTP-状态码"><a href="#7、HTTP-状态码" class="headerlink" title="7、HTTP 状态码"></a>7、HTTP 状态码</h2><p><strong>2 开头:都没问题</strong></p>
<p><strong>3 开头:需要进一步操作</strong></p>
<p><strong>4 开头:客户端出错</strong></p>
<p><strong>5 开头:服务器出错</strong></p>
<p>100: Continue<br>200: OK<br>304: Not Modified<br>400: Bad Request<br>402:不允许访问，可能登陆了也不给访问<br>403:没权限.<br>404: NotFound<br>405:请求错误<br>414:请求 url 过长<br>504:方法不被允许</p>
<h2 id="8、HTTP-1-1-和-HTTP-2"><a href="#8、HTTP-1-1-和-HTTP-2" class="headerlink" title="8、HTTP 1.1 和 HTTP 2"></a>8、HTTP 1.1 和 HTTP 2</h2><blockquote>
<p>记忆，看博客</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imququ.com/post/archives.html">看 屈光宇 JerryQu 的博客</a></p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h3><ol>
<li>HTTP 2 使用了- -进制传输，而且将 head 和 body 分成帧来传输; HTTP 1.1 字符串传输。</li>
<li>HTTP 2 支持多路复用，HTTP 1.1 不支持。 (多路复用简单来说就是一 个 TCP 连接从单车道变成了几百个双向通行的车道)。</li>
<li>HTTP 2 支持压缩 head,但 HTTP 1.1 不支持。</li>
<li>HTTP 2 支持服务器推送,但 HTTP 1.1 不支持(实际上没多少人用)。</li>
</ol>
<h1 id="TypeScript-面试题"><a href="#TypeScript-面试题" class="headerlink" title="TypeScript 面试题"></a><strong>TypeScript 面试题</strong></h1><h2 id="1、TS-和-JS-的区别是什么？有什么优势？"><a href="#1、TS-和-JS-的区别是什么？有什么优势？" class="headerlink" title="1、TS 和 JS 的区别是什么？有什么优势？"></a>1、TS 和 JS 的区别是什么？有什么优势？</h2><blockquote>
<p>对比题 &#x2F; 记忆题</p>
</blockquote>
<ol>
<li>语法层面: TypeScript &#x3D; JavaScript + Type (TS 是 JS 的超集)。</li>
<li>执行环境层面:浏览器、Node,js 可以直接执行 JS,但不能执行 TS (Deno 可以执行 TS)。</li>
<li>编译层面: TS 通过编译可以转换成 JS, JS 不用编译也可以执行(只有转译阶段「高版本变成低版本」和 lint 阶段「比如 ESlint」)。</li>
<li>编写层面: TS 更难写-点,但是<strong>类型更安全</strong>。</li>
<li>文档层面: TS 的代码写出来就是文档，IDE 可以完美<strong>提示</strong>。JS 的提示主要套 TS (是 TS 程序员贡献出来的提示，且 JS 的提示非常弱，容易出错)。</li>
</ol>
<h2 id="2、any、unknown、never-的区别是什么？"><a href="#2、any、unknown、never-的区别是什么？" class="headerlink" title="2、any、unknown、never 的区别是什么？"></a>2、any、unknown、never 的区别是什么？</h2><blockquote>
<p>对比题 &#x2F; 记忆题</p>
</blockquote>
<p><strong>any V.S. unknown</strong></p>
<p>两者都是顶级类型(top type) ,任何类型的值都可以展值给顶级类型交量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: any = <span class="number">123</span> <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: unknown = <span class="number">123</span> <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>但是 unknown 比 any 的类型检查更严格，any 什么检查都不做, unknown 要求先收窄类型(例如 as 断言):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>: unknown = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">someString</span>: string = value</span><br><span class="line"><span class="comment">// 报错：Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;.(2322)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>: unknown = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">someString</span>: string = value <span class="keyword">as</span> string; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>如果改成 any,基本在哪都不报错。所以能用 unknown 就优先用 unknown,类型更安全一点。</p>
<p>一直用 any，就变成“anyScrip”。</p>
<h2 id="3、type-和-interface-的区别是什么？"><a href="#3、type-和-interface-的区别是什么？" class="headerlink" title="3、type 和 interface 的区别是什么？"></a>3、type 和 interface 的区别是什么？</h2><blockquote>
<p>记忆题</p>
</blockquote>
<ol>
<li>组合方式: interface 使用 extends 实现继承，type 使用&amp;来实现联合类型。</li>
<li>扩展方式: interface 可以重复声明用来扩展，type 一个类型只能声明一次。</li>
<li>范围不同: type 适用于基本类型，interface 一般不行。</li>
<li>命名方式: interface 会创建新的类型名，interface 一般不行。</li>
</ol>
<h2 id="4、TS-工具类型-Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType-的作用和实现？"><a href="#4、TS-工具类型-Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType-的作用和实现？" class="headerlink" title="4、TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType 的作用和实现？"></a>4、TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType 的作用和实现？</h2><ol>
<li>翻译成中文: <br>a. Partial: 部分类型<br>b. Required:必填类型<br>c. Readonly: 只读类型<br>d. Exclude:排除类型<br>e. Extract:提取类型<br>f. Pick&#x2F;Omit:排除 key 类型<br>g. ReturnType: 返回值类型</li>
<li>举例说明每个工具类型的用法。</li>
</ol>
<p><strong>Partial 部分类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="attr">id</span>:string</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User声明了两个类型，但是user1中只给id赋了值</span></span><br><span class="line"><span class="comment">//所以就会出现报错</span></span><br><span class="line"><span class="comment">//Property &#x27;name&#x27; is missing in type &#x27;&#123; id: string; &#125;&#x27; but required in type &#x27;User&#x27;.(2741)</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user1</span>:<span class="title class_">User</span>=&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;01&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Partial就可以解决类型声明不全时会报错的问题</span></span><br><span class="line"><span class="comment">//表示只声明部分类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user2</span>:<span class="title class_">Partial</span>&lt;<span class="title class_">User</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;01&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Required 必填类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="attr">id</span>:string</span><br><span class="line">    name?:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当name带问号表示可以为defined</span></span><br><span class="line"><span class="comment">//不赋值也不会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user1</span>:<span class="title class_">User</span>=&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;01&#x27;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是如果使用了Required</span></span><br><span class="line"><span class="comment">//就代表声明类型中的每一项都是必填项</span></span><br><span class="line"><span class="comment">//不声明就会报错</span></span><br><span class="line"><span class="comment">// Property &#x27;name&#x27; is missing in type &#x27;&#123; id: string; &#125;&#x27; but required in type &#x27;Required&lt;User&gt;&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user2</span>:<span class="title class_">Required</span>&lt;<span class="title class_">User</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;01&#x27;</span>,</span><br><span class="line"> <span class="comment">// name:&#x27;111&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Readonly 只读类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="attr">id</span>:string</span><br><span class="line">    name?:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当name带问号表示可以为defined</span></span><br><span class="line"><span class="comment">//不赋值也不会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user1</span>:<span class="title class_">Readonly</span>&lt;<span class="title class_">User</span>&gt; =&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="string">&#x27;01&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Readonly表示类型值不可再赋值改变</span></span><br><span class="line"><span class="comment">//否则就会报错：Cannot assign to &#x27;id&#x27; because it is a read-only property.</span></span><br><span class="line">user1.<span class="property">id</span>=<span class="string">&#x27;02&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>Exclude 排除类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Dir</span> = <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> | <span class="string">&#x27;4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type dir1 = &quot;3&quot; | &quot;4&quot;</span></span><br><span class="line">type dir1 = <span class="title class_">Exclude</span>&lt;<span class="title class_">Dir</span>, <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Extract 提取类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Dir</span> = <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> | <span class="string">&#x27;4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type dir1 = &quot;1&quot; | &quot;2&quot;</span></span><br><span class="line">type dir1 = <span class="title class_">Extract</span>&lt;<span class="title class_">Dir</span>, <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Pick&#x2F;Omit 获取&#x2F;排除 key 类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="attr">id</span>:string</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">    <span class="attr">age</span>:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pick表示获取一个类型中的某些key</span></span><br><span class="line"><span class="comment">//此时User1就拥有了User中的id和name</span></span><br><span class="line">type <span class="title class_">User1</span>=<span class="title class_">Pick</span>&lt;<span class="title class_">User</span>,<span class="string">&#x27;id&#x27;</span>|<span class="string">&#x27;name&#x27;</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Omit则与pick相反</span></span><br><span class="line"><span class="comment">//表示排除一个类型的某些key</span></span><br><span class="line"><span class="comment">//type User2 = &#123;age: string;&#125;</span></span><br><span class="line">type <span class="title class_">User2</span>=<span class="title class_">Omit</span>&lt;<span class="title class_">User</span>,<span class="string">&#x27;id&#x27;</span>|<span class="string">&#x27;name&#x27;</span> &gt;</span><br></pre></td></tr></table></figure>

<p><strong>ReturnType 返回值类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: number, b: number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type A = number</span></span><br><span class="line">type A = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f&gt;</span><br></pre></td></tr></table></figure>

<h1 id="VUE2-面试题"><a href="#VUE2-面试题" class="headerlink" title="VUE2 面试题"></a><strong>VUE2 面试题</strong></h1><h2 id="1、Vue-2-的生命周期钩子有哪些？数据请求放在哪个钩子？"><a href="#1、Vue-2-的生命周期钩子有哪些？数据请求放在哪个钩子？" class="headerlink" title="1、Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？"></a>1、Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？</h2><h3 id="有哪些-amp-作用"><a href="#有哪些-amp-作用" class="headerlink" title="有哪些&amp;作用"></a><strong>有哪些&amp;作用</strong></h3><p>8 个常用，3 个不常用</p>
<ol>
<li>beforeCreate Vue 实例初始化后、但在组件实例被创建之前<br>. created 组件实例已经完全创建之后<br>. beforeMount 组件挂载之前<br>. mounted 组件被挂载到实例上去之后<br>. beforeUpdate 组件数据更新之前<br>. updated 组件数据更新之后<br>. beforeDestroy 组件实例销毁之前<br>. destroyed 组件实例销毁之后<br>. activated 被 keep-alive 缓存的组件激活时</li>
</ol>
<p>. deactivated 被 keep-alive 缓存的组件停用时调用<br>. errorCaptured 当子孙组件发生错误时被调用</p>
<h3 id="数据请求放在哪个钩子？"><a href="#数据请求放在哪个钩子？" class="headerlink" title="数据请求放在哪个钩子？"></a><strong>数据请求放在哪个钩子？</strong></h3><p>create 和 mounted 都可以</p>
<h3 id="真实的-dom-挂在完在哪个钩子？"><a href="#真实的-dom-挂在完在哪个钩子？" class="headerlink" title="真实的 dom 挂在完在哪个钩子？"></a><strong>真实的 dom 挂在完在哪个钩子？</strong></h3><p>mounted</p>
<h2 id="2、组件之间的通信"><a href="#2、组件之间的通信" class="headerlink" title="2、组件之间的通信"></a>2、组件之间的通信</h2><ol>
<li>父子组件:使用「props 和事件」进行通信</li>
<li>爷孙组件:<br>a.使用两次父子组件间通信来实现(儿子传给爸爸,爸爸传给爷爷)<br>b.使用「provide + inject」 来通信(在爷爷那里提供一个东西， 在孙子这里注入一个东西)</li>
<li>任意组件:<br>a.使用 eventBus &#x3D; new Vue()来通信<br> i.API:使用 eventBus.$on 来监听，使佣 eventBus. $emit 来触发<br> ii.缺点:事件多了就很乱， 「难以维护」<br>b.使用 Vuex 通信(Vue3 可用 Pinia 代替 Vuex)</li>
</ol>
<h2 id="3、Vuex"><a href="#3、Vuex" class="headerlink" title="3、Vuex"></a>3、Vuex</h2><ol>
<li>背下文档第一 句话: Vuex 是一个状态管理库</li>
<li>说出核心概念的名字和作用: store&#x2F;State&#x2F;Getter&#x2F;Mutation&#x2F;Action&#x2F;Module。<br> a.store 是个大容器，包含以下所有内容。<br> b. State 是用来<strong>读取状态</strong>，带有-个 mapState 辅助函数。<br> c. Getter 用来<strong>读取派生(计算出来的)状态</strong>，附有一个 mapGetters 辅助函数。<br> d. Mutation 用于<strong>同步提交状态变更</strong>，附有一个 mapMutations 辅助函数。<br> e. Action 用于<strong>异步变更状态</strong>，但它提交的是 mutation,而不是直接更改状态。<br> f. Module 用来给 store 划分模块,方便维护代码。</li>
</ol>
<p><strong>常见追问</strong></p>
<ol>
<li>Mutation 和 Action 的区别<br>Mutation 是同步的写状态，Action 是异步的写状态</li>
<li>Mutation 和 Action 为什么要分开<br>为了让代码更容易维护</li>
<li>可是 Pinia 就把 Mutation 和 Action 合并了呀<br>这样会减少一个概念,会让代码更容易理解</li>
</ol>
<blockquote>
<p>复杂是为了更容易维护,简单是为了更容易理解</p>
</blockquote>
<h2 id="4、VueRouter"><a href="#4、VueRouter" class="headerlink" title="4、VueRouter"></a>4、VueRouter</h2><ol>
<li><p>Vue Router 是 Vue 官方推荐的<strong>路由管理器</strong>，用于做单页面应用的</p>
</li>
<li><p>说出核心概念的名字和作用:<br> a. router-link、router-view 嵌套路由<br>b. Hash 模式和 History 模式<br>c.导航守卫<br>d.懒加载</p>
</li>
<li><p>常见追问: <br>a. Hash 模式和 History 模式的区别?<br> i .一个用的 URL 的 Hash,一一个用的 HTML5 的 History API<br> ii. Hash 模式 不需要后端 nginx 配合, History 需要后端配合的<br>b.导航守卫如何实现登陆控制?</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) <span class="keyword">return</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">if</span> (to是受控页面 &amp;&amp; 没有登录) <span class="keyword">return</span> <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​ c.懒加载<br> i. import()</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36521655/article/details/106125910">推荐：路由守卫博客</a></p>
<h2 id="5、Vue-双向绑定-x2F-数据响应式"><a href="#5、Vue-双向绑定-x2F-数据响应式" class="headerlink" title="5、Vue 双向绑定&#x2F;数据响应式"></a>5、Vue 双向绑定&#x2F;数据响应式</h2><ol>
<li>一般使用 v-model &#x2F; .sync 实现，v-model 是 v-bind: value 和 v-on: input 的<strong>语法糖</strong>。<br>a.v- -bind: value 实现了 data -&gt; UI 的单向绑定。<br>b. v-on: input 实现了 UI -&gt; data 的单向绑定。<br>c.两个单向绑定加起来就是实现双向绑定了。</li>
<li>这两个单项绑定是如何实现的。<br>a.第一个向绑定通过<strong>Object.defineProperty</strong> API 给 data 每一个属性递归的 创建 getter 和 setter,用于监听&#x2F;劫持 data 的改变。<br>b.第二个单向绑定通过 template <strong>compiler</strong>给 DOM 添加事件监听,只要 DOM input 的值发生变化，就会去修改对应的 data。</li>
</ol>
<p><strong>原理</strong></p>
<ol>
<li>使用<strong>objec.efineProperty</strong>把这些属性全部转为<strong>getter&#x2F;setter</strong></li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li>不能检测到对象属性的添加或删除<br>·使用 vue.set 或者 vm.$set 来解决</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/canfoo/p/6891868.html">博客链接</a></p>
<h2 id="6、watch-和-computed-区别"><a href="#6、watch-和-computed-区别" class="headerlink" title="6、watch 和 computed 区别"></a>6、watch 和 computed 区别</h2><p><strong>watch</strong></p>
<ul>
<li>「侦听属性」，会对 data 的数据监听回调，当依赖的 data 的数据变化时，会执行回调。</li>
<li>[支持异步」</li>
<li>一对多，一个值得变化，引起多个目标值的变化。</li>
</ul>
<p><strong>computed</strong></p>
<ul>
<li>「计算属性」，它会根据你所依赖的数据动态显示新的计算结果。</li>
<li>[支持缓存」，计算 属性是基于它们的响应式依赖进行缓存的，只有依赖数据发生改变,才会重新进行计算。</li>
<li>「不支持异步」，当 computed 内有异步操作时，将无法监听数据的变化。</li>
<li>对于任何复杂逻辑,都应该使用计算属性。</li>
<li>多对一，多个值的变化决定-个目标值的变化。</li>
</ul>
<h1 id="VUE3-面试题"><a href="#VUE3-面试题" class="headerlink" title="VUE3 面试题"></a><strong>VUE3 面试题</strong></h1><h2 id="1、Vue-3-为什么使用-Proxy"><a href="#1、Vue-3-为什么使用-Proxy" class="headerlink" title="1、Vue 3 为什么使用 Proxy"></a>1、Vue 3 为什么使用 Proxy</h2><ol>
<li>弥补 Object.defineProperty 的两个不足<br>a.动态创建的 data 属性需要用 Vue.set 来赋值，Vue3 使用了 Proxy 就不需要了<br>b.基于性能考虑, Vue2 篡改了数组的 7 个 API, Vue3 用了 Proxy 就不需要了</li>
<li>defineProperty 需要提前递归地遍历 data 做到响应式,而 Proxy 可以再真正用到深层数据的时候再做响应式(惰性)</li>
</ol>
<h2 id="2、Vue3-为什么使用-Composition-API？"><a href="#2、Vue3-为什么使用-Composition-API？" class="headerlink" title="2、Vue3 为什么使用 Composition API？"></a>2、Vue3 为什么使用 Composition API？</h2><ol>
<li>Composition API 比 mixins、extends、 高阶组件、Renderless Components 等更好，原因:<br>a.模板中的数据来源不清晰:很多时候不知道一鲂法从哪里来的，比如有两个 mixins,并不知道 log 方法来自 A 还是来自 B,只能靠猜<br>b.命名空间冲突:两个 mixins 朋了两个 log 方法,就不知道 log 的时候用了哪个 log 方法<br>c.性能:只要指 Renderless Components</li>
<li>更适合 TypeScrip<br>a.用 mixins 和 extends 很难写</li>
</ol>
<h2 id="3、Vue3-对比-Vue2-做了哪些改动？"><a href="#3、Vue3-对比-Vue2-做了哪些改动？" class="headerlink" title="3、Vue3 对比 Vue2 做了哪些改动？"></a>3、Vue3 对比 Vue2 做了哪些改动？</h2><ol>
<li>使用 createApp0 代替了 new Vue()</li>
<li>v-model 升级，代替了以前的 v-model 和.sync<br>a. v-model 面可以接 name (value 的名字)</li>
<li>根元素可以有不止一个元素了(可以有多个根元素)</li>
<li>新增 Teleport:传送门</li>
<li>destroyed 改名为 unmounted &#x2F; beforeUnmount</li>
<li>ref 属性支持函数</li>
</ol>
<h1 id="React-面试题"><a href="#React-面试题" class="headerlink" title="React 面试题"></a><strong>React 面试题</strong></h1><h2 id="1、虚拟-DOM-原理"><a href="#1、虚拟-DOM-原理" class="headerlink" title="1、虚拟 DOM 原理"></a>1、虚拟 DOM 原理</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7072322818217607198">博客链接</a></p>
<p><strong>回答：</strong></p>
<ul>
<li>虚拟 DOM 就是虚拟节点，用 JS 对象来模拟 DOM 点,然后递归渲染成真实的 DOM 节点</li>
<li>用 JSX 写咄来的 div 就是一个虚拟 DOM，它其实是一个 JS 对象</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li>有两个重要的过程:<br>a.用 JS 对象模拟 DOM 节点<br>b.把模拟节点变成真实节点</li>
<li>模拟节点:<br>a. JSX 语法写出的代码会被转译成<strong>JS 对象</strong>，这个<strong>对象</strong>里，包含很多标签,比如: tag、props、children 等<br>b.这个<strong>对象</strong>用来模拟一个标签,这就是<strong>虚拟节点</strong></li>
<li>渲染成真实节点:<br>a.递归的遍历过程<br>b.根据上面对象里的<strong>tag</strong>来创建<strong>对应的节点</strong>(element)<br>c.根据<strong>props</strong>来给节点(element)添加属性<br>d.根据<strong>children</strong>来添加子节点</li>
<li>DOM diff<br>a.<strong>对比两个虚拟 DOM</strong>树的算法<br>b.当组件变化时，会 render 出-个新的<strong>虚拟 DOM</strong>, diff 算法<strong>对比新旧 虚拟 DOM</strong>后，得到一个<strong>patch</strong>,然后 React 用<strong>patch</strong>来<strong>更新 DOM</strong></li>
</ol>
<h2 id="2、React-或-Vue-的-DOM-diff-算法"><a href="#2、React-或-Vue-的-DOM-diff-算法" class="headerlink" title="2、React 或 Vue 的 DOM diff 算法"></a>2、React 或 Vue 的 DOM diff 算法</h2><p>对比 <strong>两棵虚拟 DOM 树</strong>区别，然后找出其中不同的部分</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44403976/article/details/123607037">慢慢了解这个博客内容</a></p>
<p><strong>总结：</strong></p>
<ol>
<li>react-diff: 遍历法对比</li>
<li>vue-diff: 双端对比</li>
<li>总体来讲 vue 的 diff 算法更佳,总体规律就是找到新节点所对应的旧节点列表中的节点,而后给真实的对应的 dom 移动到正确的位置</li>
<li>vue3.0 的 diff 算法还没有梳理过,以后可以在说 vue3.0 其他东西的时候带上,一些更改的地方该了解的还是要了解的</li>
</ol>
<h2 id="3、-生命周期钩子函数"><a href="#3、-生命周期钩子函数" class="headerlink" title="3、 生命周期钩子函数"></a>3、 生命周期钩子函数</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\许大胖子许可爱许宝贝\Desktop\image.png"></p>
<h3 id="回答一："><a href="#回答一：" class="headerlink" title="回答一："></a><strong>回答一：</strong></h3><p>实 React 的生命周期不太好记，我平时是这么分的</p>
<ol>
<li>我分为 3 个阶段:创建时，更新时,卸载时候</li>
</ol>
<h3 id="回答二："><a href="#回答二：" class="headerlink" title="回答二："></a><strong>回答二：</strong></h3><p>React 的生命周期比较难记，总结的来说:</p>
<ol>
<li>挂载时调用 constructor,更新时不调用</li>
<li>更新时调用 shouldComponentUpdate 和 getSnapshotBeforeUpdate,挂载时不调用</li>
<li>shouldComponentUpdate 在 render 前调用，getSnapshotBeforeUpdate 后调用</li>
</ol>
<h2 id="4、如何实现组件间通信"><a href="#4、如何实现组件间通信" class="headerlink" title="4、如何实现组件间通信"></a>4、如何实现组件间通信</h2><p>所谓通信，就是发数据</p>
<ol>
<li>父好组件通信: props +函数</li>
<li>爷孙组件通信:两层父子通信或者使用 Context API,使佣 Context.Provider [写 value」和 Context.Consumer「 获取 vale」</li>
<li>任意组件通信:变成了状态管理了<br>a. Redux<br>b. Mobx <br><br>c. Recoil</li>
</ol>
<h2 id="5、Redux"><a href="#5、Redux" class="headerlink" title="5、Redux"></a>5、Redux</h2><ol>
<li>Redux 是一个状态管理库&#x2F;状态容器</li>
<li>redux 的核心概念<br>a.<strong>单一数据源</strong><br> [当我们有多个数据需要放到 redux 中管理时，是放在一个对象里，这个对象放在 store 中管理，虽然 redux 并没有强制只能创建一个 store，但是多个数据源的话不那么容易管理，单一的数据源可以更好的追踪状态的变化。]<br>b.<strong>state 是只读的</strong><br>[想要改变 state，无法在组件上直接手动修改 state 的值，这样可以保证状态不会被随意改变，唯一的方式就是派发 action，而是通过集中管理的形式去改变 state。]<br>c.<strong>reducer 是纯函数</strong><br>[纯函数指的是有相同的输入必定有相同的输出，在这种情况下，不可以修改入参，也不能发送网络请求，也不能进行获取随机数这样的操作，通过 reducer 将上一个 state 的状态和当前派发的 action 连接起来，返回一个新的状态。]</li>
</ol>
<h2 id="6、高阶组件-HOC"><a href="#6、高阶组件-HOC" class="headerlink" title="6、高阶组件 HOC"></a>6、高阶组件 HOC</h2><p>参数是组件,返回值也是组件的函数。什么都能做，所以抽象问题就举例回答。</p>
<ol>
<li>React.forwardRef</li>
<li>ReactRedux 的 connect</li>
<li>ReactRouter 的 withRouter</li>
</ol>
<h2 id="7、React-Hooks-如何模拟组件生命周期？"><a href="#7、React-Hooks-如何模拟组件生命周期？" class="headerlink" title="7、React Hooks 如何模拟组件生命周期？"></a>7、React Hooks 如何模拟组件生命周期？</h2><ol>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ol>
<h2 id="8、受控组件-V-S-非受控组件"><a href="#8、受控组件-V-S-非受控组件" class="headerlink" title="8、受控组件 V.S. 非受控组件"></a>8、受控组件 V.S. 非受控组件</h2><h3 id="回答一：-1"><a href="#回答一：-1" class="headerlink" title="回答一："></a><strong>回答一：</strong></h3><ul>
<li>如果给一个组件传 了 value 和 onChange,输入输出都被控制的，那么这个组件就是受控组件。</li>
<li>如果只给-个组件传了 defaultValueI 默认值」，没有传 onChange,那么就是非受控组件，因为没有完全受到控制</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&#123;x&#125; onchange=&#123;fn&#125;&gt;&lt;<span class="regexp">/input&gt; /</span><span class="regexp">/ 受控组件</span></span><br><span class="line"><span class="regexp">&lt;input default=&#123;x&#125;&gt;&lt;/i</span>nput&gt; <span class="comment">// 非受控组件</span></span><br></pre></td></tr></table></figure>

<h3 id="回答二：-1"><a href="#回答二：-1" class="headerlink" title="回答二："></a><strong>回答二：</strong></h3><p><strong>什么是：</strong></p>
<ul>
<li>被的 state<strong>控制</strong>，就是<strong>受控组件</strong>。</li>
<li>不被 state<strong>控制</strong>，就是<strong>非受控</strong>。</li>
</ul>
<p><strong>怎么做能：</strong></p>
<ul>
<li>受控组件的实现:设置 state,使用事件调用 setstate,更新数据和视图。</li>
<li>非受控组件的实现:避开 state,使用 ref 等方式，更新数据和视图。</li>
</ul>
<h1 id="Webpack-面试题"><a href="#Webpack-面试题" class="headerlink" title="Webpack 面试题"></a><strong>Webpack 面试题</strong></h1><h2 id="1、webpack-的理解？解决了什么问题？"><a href="#1、webpack-的理解？解决了什么问题？" class="headerlink" title="1、webpack 的理解？解决了什么问题？"></a>1、webpack 的理解？解决了什么问题？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30071415/article/details/117215651">(1 条消息) Webpack 的理解以及解决的问题_Silvia250 的博客-CSDN 博客</a></p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h3><p>webpack 是一个模块打包工具，他可以管理项目中的模块依赖，并编译输出模块所需的静态文件。webpack 可以很好的管理、打包开发中所用到的 HTML、CSS、JavaScript 和静态文件（图片、字体），让开发更高效。对于不同类型的依赖，webpack 有不同的模块加载器，而且会分析模块间的依赖关系，最终合并生成优化的静态资源。</p>
<h3 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a><strong>解决问题：</strong></h3><ul>
<li>「编译代码能力」，提高效率，解决浏览器兼容问题。</li>
<li>「模块整合能力」，提高性能，可维护性，解决浏览器频繁请求文件的问题。</li>
<li>「万物皆可模块能力」，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制。</li>
</ul>
<h2 id="2、webpack-的构建流程"><a href="#2、webpack-的构建流程" class="headerlink" title="2、webpack 的构建流程?"></a>2、webpack 的构建流程?</h2><p>webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统，在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果</li>
</ol>
<h2 id="3、webpack-中常见的-Loader？解决了什么问题？"><a href="#3、webpack-中常见的-Loader？解决了什么问题？" class="headerlink" title="3、webpack 中常见的 Loader？解决了什么问题？"></a>3、webpack 中常见的 Loader？解决了什么问题？</h2><ol>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li>
<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ol>
<h2 id="4、webpack-中常见的-Plugin？解决了什么问题？"><a href="#4、webpack-中常见的-Plugin？解决了什么问题？" class="headerlink" title="4、webpack 中常见的 Plugin？解决了什么问题？"></a>4、webpack 中常见的 Plugin？解决了什么问题？</h2><ol>
<li>DLLPlugin 常用插件 对 webpack 构建进行优化 DLLReferencePlugin 将 DllPlugin 会自动引入编译后文件</li>
<li>NpmInstallWebpackPlugin 运行 npm run start 会自动下载依赖</li>
<li>ProvidePlugin 无需 import 引入插件 如 jquery</li>
<li>html-webpack-plugin：压缩 html</li>
<li>clean-webpack-plugin：打包器清理源目录文件，在 webpack 打包器清理 dist 目录</li>
</ol>
<p>记几点就好</p>
<h2 id="5、Loader-和-Plugin-的区别？编写-Loader，Plugin-的思路？"><a href="#5、Loader-和-Plugin-的区别？编写-Loader，Plugin-的思路？" class="headerlink" title="5、Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？"></a>5、Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</h2><h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a><strong>区别：</strong></h3><ol>
<li>不同的作用<br>1.1 Loader 直译为”加载器”。webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。<br>1.2 Plugin 直译为”插件”，Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果</li>
<li>不同的用法<br>2.1 Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）<br>2.2 Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都<br>通过构造函数传入。</li>
</ol>
<h3 id="编写思路："><a href="#编写思路：" class="headerlink" title="编写思路："></a><strong>编写思路：</strong></h3><ol>
<li>编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作， 每个 Loader<br>的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用<br>this.callback()方法，将内容返回给 webpack，还可以通过 this.async()生成一个 callback 函数，再<br>用这个 callback 将处理后的内容输出出去，此外 webpack 还为开发者准备了开发 loader 的工具函<br>数集——loader-utils</li>
<li>相对于 Loader 而言，Plugin 的编写就灵活了许多， webpack 在运行的生命周期中<br>会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输<br>出结果</li>
</ol>
<h3 id="编写注意事项："><a href="#编写注意事项：" class="headerlink" title="编写注意事项："></a><strong>编写注意事项：</strong></h3><ol>
<li>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情</li>
<li>Loader 运行在 node.js 中，我们可以调用任意 node.js 自带的 API 或者安装第三方模块进行调用</li>
<li>webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw &#x3D; true 告诉 webpack 该 Loader 是否需要二进制数据</li>
<li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li>
<li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li>
<li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li>
<li>加载本地 Loader 方法</li>
</ol>
<h2 id="6、webpack-的热更新是如何做到的？原理是什么？"><a href="#6、webpack-的热更新是如何做到的？原理是什么？" class="headerlink" title="6、webpack 的热更新是如何做到的？原理是什么？"></a>6、webpack 的热更新是如何做到的？原理是什么？</h2><ul>
<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和 Socket 服务</li>
<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>
<li>socket server 是一个 websocket 的长连接，双方可以通信</li>
<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）</li>
<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>
<li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新</li>
</ul>
<h2 id="7、webpack-proxy-工作原理？为什么能解决跨域"><a href="#7、webpack-proxy-工作原理？为什么能解决跨域" class="headerlink" title="7、webpack proxy 工作原理？为什么能解决跨域?"></a>7、webpack proxy 工作原理？为什么能解决跨域?</h2><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器，通过 proxy 实现代理请求后，会在浏览器与服务器之间添加一个代理服务器，本地发送请求时，中间代理服务器接收后转发给目标服务器，目标服务器返回数据，中间代理服务器将数据返回给浏览器。中间代理服务器与目标服务器之间不存在跨域资源问题。</p>
<h2 id="8、如何借助-webpack-来优化前端性能？"><a href="#8、如何借助-webpack-来优化前端性能？" class="headerlink" title="8、如何借助 webpack 来优化前端性能？"></a>8、如何借助 webpack 来优化前端性能？</h2><ol>
<li>压缩代码。uglifyJsPlugin 压缩 js 代码， mini-css-extract-plugin 压缩 css 代码</li>
<li>利用 CDN 加速，将引用的静态资源修改为 CDN 上对应的路径，可以利用 webpack 对于 output 参数和 loader 的 publicpath 参数来修改资源路径</li>
<li>删除死代码（tree shaking），css 需要使用 Purify-CSS</li>
<li>提取公共代码。webpack4 移除了 CommonsChunkPlugin (提取公共代码)，用 optimization.splitChunks 和 optimization.runtimeChunk 来代替</li>
</ol>
<h2 id="9、提高-webpack-的构建速度"><a href="#9、提高-webpack-的构建速度" class="headerlink" title="9、提高 webpack 的构建速度"></a>9、提高 webpack 的构建速度</h2><p>在多入口情况下，使用 CommonsChunkPlugin 来提取公共代码</p>
<ol>
<li>通过 externals 配置来提取常用库</li>
<li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li>
<li>使用 Happypack 实现多线程加速编译</li>
<li>使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度</li>
<li>使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码</li>
</ol>
<h2 id="10、与-webpack-类似的工具还有哪些？区别？"><a href="#10、与-webpack-类似的工具还有哪些？区别？" class="headerlink" title="10、与 webpack 类似的工具还有哪些？区别？"></a>10、与 webpack 类似的工具还有哪些？区别？</h2><ol>
<li><h3 id="Rollup-（代码效率更简洁、效率更高，默认支持-Tree-shaking）"><a href="#Rollup-（代码效率更简洁、效率更高，默认支持-Tree-shaking）" class="headerlink" title="Rollup （代码效率更简洁、效率更高，默认支持 Tree-shaking）"></a>Rollup （代码效率更简洁、效率更高，默认支持 Tree-shaking）</h3></li>
</ol>
<h1 id="Js-垃圾回收面试题"><a href="#Js-垃圾回收面试题" class="headerlink" title="Js 垃圾回收面试题"></a>Js 垃圾回收面试题</h1><h2 id="1、JS-里垃圾回收机制是什么，常用的是哪种，怎么处理的？"><a href="#1、JS-里垃圾回收机制是什么，常用的是哪种，怎么处理的？" class="headerlink" title="1、JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的？"></a>1、JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的？</h2><p>JS 的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>
<p>JS 中最常见的垃圾回收方式是标记清除。</p>
<p>工作原理：<br>是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存<br>工作流程：</p>
<ol>
<li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记</li>
<li>去掉环境中的变量以及被环境中的变量引用的变量的标记</li>
<li>再被加上标记的会被视为准备删除的变量</li>
<li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间</li>
</ol>
<h1 id="Eventloop-面试题"><a href="#Eventloop-面试题" class="headerlink" title="Eventloop 面试题"></a>Eventloop 面试题</h1><h2 id="1、什么是-事件循环-x2F-Event-Loop"><a href="#1、什么是-事件循环-x2F-Event-Loop" class="headerlink" title="1、什么是 事件循环&#x2F;Event Loop"></a>1、什么是 事件循环&#x2F;Event Loop</h2><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</p>
<h2 id="2、说一下事件循环-eventloop"><a href="#2、说一下事件循环-eventloop" class="headerlink" title="2、说一下事件循环 eventloop"></a>2、说一下事件循环 eventloop</h2><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行 3</li>
<li>取出任务队列的首部，加入执行栈</li>
<li>执行任务</li>
<li>检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">前端面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/tent.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/img/qq.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/qq.jpg" alt="QQ"/></a><div class="post-qr-code-desc">QQ</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/52658.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tent.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">meta-viewport标签</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/61730.html" title="2022新版前端面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/four.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-07</div><div class="title">2022新版前端面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ga.x</div><div class="author-info__description">Ga.X个人博客,记录个人学习,分享一些无用的方法跟技巧；小兔鲜商城项目在线网址：dididididii.xyz;参考源码在关于页面查看。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dididididii"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dididididii" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_48023110" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1281627297&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1281627297@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">此博客纯属分享一些无用的东西,希望各大佬喷轻点,本人只会复制粘贴。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">HTML 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81HTML-%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">1、HTML 语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81meta-x2F-viewport-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">2、meta &#x2F; viewport 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#meta-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">meta 标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#viewport"><span class="toc-number">1.2.2.</span> <span class="toc-text">viewport</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B-HTML5-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.3.</span> <span class="toc-text">3、用过哪些 HTML5 标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Canvas-%E5%92%8C-SVG-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4、Canvas 和 SVG 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81H5-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.</span> <span class="toc-text">5、H5 是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">CSS 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E7%A7%8D%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">1、两种盒模型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2、如何实现垂直居中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81flex-%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3、flex 怎么用，常用属性有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">常用属性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81BFC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4、BFC 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.5.</span> <span class="toc-text">5、CSS 选择器优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">2.6.</span> <span class="toc-text">6、清除浮动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">JavaScript 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.1.</span> <span class="toc-text">1、数据类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.2.</span> <span class="toc-text">2、原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">答题思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">如何创建一个原型链：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">原型链解决了什么问题:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">3.2.5.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">3.2.6.</span> <span class="toc-text">怎么解决缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81this"><span class="toc-number">3.3.</span> <span class="toc-text">3、this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">方法一：转换代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%83%8C-this-%E6%8C%87%E5%90%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">方法二：背 this 指向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81new-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.</span> <span class="toc-text">4、new 做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81call%E3%80%81apply%E3%80%81bind"><span class="toc-number">3.5.</span> <span class="toc-text">5、call、apply、bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">6、立即执行函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="toc-number">3.6.1.</span> <span class="toc-text">是什么：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9A"><span class="toc-number">3.6.2.</span> <span class="toc-text">怎么做：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.6.3.</span> <span class="toc-text">解决了什么问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">3.6.4.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">3.6.5.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-number">3.6.6.</span> <span class="toc-text">怎么解决：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-number">3.7.</span> <span class="toc-text">7、闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A-1"><span class="toc-number">3.7.1.</span> <span class="toc-text">是什么：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9A-1"><span class="toc-number">3.7.2.</span> <span class="toc-text">怎么做：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9A-1"><span class="toc-number">3.7.3.</span> <span class="toc-text">解决了什么问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-number">3.7.4.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-number">3.7.5.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">3.7.6.</span> <span class="toc-text">怎么解决缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.8.</span> <span class="toc-text">8、如何实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.8.1.</span> <span class="toc-text">方法一：使用原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8-class"><span class="toc-number">3.8.2.</span> <span class="toc-text">方法二：使用 class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">3.9.</span> <span class="toc-text">9、如何实现继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9A%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96"><span class="toc-number">3.10.</span> <span class="toc-text">10、手写：节流、防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">3.10.1.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">3.10.2.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.10.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">3.10.4.</span> <span class="toc-text">应用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">3.11.</span> <span class="toc-text">11、手写：发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9AAJAX"><span class="toc-number">3.12.</span> <span class="toc-text">12、手写：AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E7%89%88%EF%BC%9A"><span class="toc-number">3.12.1.</span> <span class="toc-text">简易版：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%9A"><span class="toc-number">3.12.2.</span> <span class="toc-text">完整版：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9A%E7%AE%80%E5%8C%96%E7%89%88-Promise"><span class="toc-number">3.13.</span> <span class="toc-text">13、手写：简化版 Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9APromise-all-%E6%9C%AA%E8%A7%A3%E5%86%B3"><span class="toc-number">3.14.</span> <span class="toc-text">14、手写：Promise.all (未解决)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E6%89%8B%E5%86%99%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.15.</span> <span class="toc-text">15、手写：深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%94%A8-JSON"><span class="toc-number">3.15.1.</span> <span class="toc-text">方法一：用 JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%94%A8%E9%80%92%E5%BD%92"><span class="toc-number">3.15.2.</span> <span class="toc-text">方法二：用递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">3.16.</span> <span class="toc-text">16、数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%94%BE%E5%BC%83%E9%A2%98%EF%BC%9A-x3D-x3D-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98"><span class="toc-number">3.17.</span> <span class="toc-text">17、放弃题：&#x3D;&#x3D; 相关的题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%B8%8D%E7%94%A8-class-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F%E7%94%A8-class-%E5%8F%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">3.18.</span> <span class="toc-text">18、不用 class 如何实现继承？用 class 又如何实现继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E6%AD%A3%E5%88%99%E5%AE%9E%E7%8E%B0-trim"><span class="toc-number">3.19.</span> <span class="toc-text">19、正则实现 trim()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81async-x2F-await%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">3.20.</span> <span class="toc-text">20、async&#x2F;await，如何捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81JSONP%E3%80%81CORS%E3%80%81%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.21.</span> <span class="toc-text">21、JSONP、CORS、跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81Promise%E3%80%81Promise-all%E3%80%81Promise-race-%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E7%94%A8-%E6%9C%AA%E8%A7%A3%E5%86%B3"><span class="toc-number">3.22.</span> <span class="toc-text">22、Promise、Promise.all、Promise.race 分别怎么用 (未解决)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81ES6-%E8%AF%AD%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.23.</span> <span class="toc-text">23、ES6 语法有哪些，分别是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">DOM 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81DOM-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1、DOM 事件模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">4.2.</span> <span class="toc-text">2、事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%89%88%EF%BC%88%E4%BD%86%E5%8F%AF%E4%BB%A5%E8%BF%87%EF%BC%89%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">错误版（但可以过）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%88%EF%BC%88%E4%B8%8D%E7%94%A8%E8%83%8C%EF%BC%89%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">高级版（不用背）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-number">4.2.3.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-number">4.2.4.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-number">4.2.5.</span> <span class="toc-text">如何解决：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%94%A8-mouse-%E4%BA%8B%E4%BB%B6%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84-div"><span class="toc-number">4.3.</span> <span class="toc-text">3、用 mouse 事件写一个可拖拽的 div</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">HTTP 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81GET-%E5%92%8C-POST-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">1、GET 和 POST 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%80%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">5.1.1.</span> <span class="toc-text">区别一：幂等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BA%8C%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">区别二：请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%89%EF%BC%9ATCP-packet"><span class="toc-number">5.1.3.</span> <span class="toc-text">区别三：TCP packet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="toc-number">5.1.4.</span> <span class="toc-text">补充：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HTTP-%E7%BC%93%E5%AD%98"><span class="toc-number">5.2.</span> <span class="toc-text">2、HTTP 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E7%82%B9%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">考点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3、HTTP 和 HTTPS 的区别有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E5%88%97%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">区别列表：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4、TCP 三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.4.3.</span> <span class="toc-text">TCP 是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E4%B8%8E-%E8%B7%A8%E5%9F%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5、同源策略 与 跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">5.5.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">跨域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Session%E3%80%81Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.6.</span> <span class="toc-text">6、Session、Cookie、LocalStorage、SessionStorage 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.7.</span> <span class="toc-text">7、HTTP 状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81HTTP-1-1-%E5%92%8C-HTTP-2"><span class="toc-number">5.8.</span> <span class="toc-text">8、HTTP 1.1 和 HTTP 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.8.1.</span> <span class="toc-text">区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">TypeScript 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TS-%E5%92%8C-JS-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1、TS 和 JS 的区别是什么？有什么优势？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81any%E3%80%81unknown%E3%80%81never-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2、any、unknown、never 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81type-%E5%92%8C-interface-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3、type 和 interface 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TS-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B-Partial%E3%80%81Required%E3%80%81Readonly%E3%80%81Exclude%E3%80%81Extract%E3%80%81Omit%E3%80%81ReturnType-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4、TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、ReturnType 的作用和实现？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VUE2-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">VUE2 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Vue-2-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1、Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B-amp-%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">有哪些&amp;作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">数据请求放在哪个钩子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E7%9A%84-dom-%E6%8C%82%E5%9C%A8%E5%AE%8C%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">7.1.3.</span> <span class="toc-text">真实的 dom 挂在完在哪个钩子？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">7.2.</span> <span class="toc-text">2、组件之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Vuex"><span class="toc-number">7.3.</span> <span class="toc-text">3、Vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81VueRouter"><span class="toc-number">7.4.</span> <span class="toc-text">4、VueRouter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-x2F-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">7.5.</span> <span class="toc-text">5、Vue 双向绑定&#x2F;数据响应式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81watch-%E5%92%8C-computed-%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.</span> <span class="toc-text">6、watch 和 computed 区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VUE3-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">VUE3 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Vue-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Proxy"><span class="toc-number">8.1.</span> <span class="toc-text">1、Vue 3 为什么使用 Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Vue3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Composition-API%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">2、Vue3 为什么使用 Composition API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Vue3-%E5%AF%B9%E6%AF%94-Vue2-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8A%A8%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">3、Vue3 对比 Vue2 做了哪些改动？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">React 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%99%9A%E6%8B%9F-DOM-%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">1、虚拟 DOM 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81React-%E6%88%96-Vue-%E7%9A%84-DOM-diff-%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">2、React 或 Vue 的 DOM diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">3、 生命周期钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E4%B8%80%EF%BC%9A"><span class="toc-number">9.3.1.</span> <span class="toc-text">回答一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E4%BA%8C%EF%BC%9A"><span class="toc-number">9.3.2.</span> <span class="toc-text">回答二：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">9.4.</span> <span class="toc-text">4、如何实现组件间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Redux"><span class="toc-number">9.5.</span> <span class="toc-text">5、Redux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC"><span class="toc-number">9.6.</span> <span class="toc-text">6、高阶组件 HOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81React-Hooks-%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">7、React Hooks 如何模拟组件生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-V-S-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">9.8.</span> <span class="toc-text">8、受控组件 V.S. 非受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E4%B8%80%EF%BC%9A-1"><span class="toc-number">9.8.1.</span> <span class="toc-text">回答一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E4%BA%8C%EF%BC%9A-1"><span class="toc-number">9.8.2.</span> <span class="toc-text">回答二：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">Webpack 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81webpack-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">1、webpack 的理解？解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">10.1.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">10.1.2.</span> <span class="toc-text">解决问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">10.2.</span> <span class="toc-text">2、webpack 的构建流程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81webpack-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84-Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">3、webpack 中常见的 Loader？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81webpack-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84-Plugin%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">4、webpack 中常见的 Plugin？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Loader-%E5%92%8C-Plugin-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BC%96%E5%86%99-Loader%EF%BC%8CPlugin-%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">5、Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A-1"><span class="toc-number">10.5.1.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">10.5.2.</span> <span class="toc-text">编写思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">10.5.3.</span> <span class="toc-text">编写注意事项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">6、webpack 的热更新是如何做到的？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81webpack-proxy-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">10.7.</span> <span class="toc-text">7、webpack proxy 工作原理？为什么能解决跨域?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9-webpack-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">10.8.</span> <span class="toc-text">8、如何借助 webpack 来优化前端性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%8F%90%E9%AB%98-webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="toc-number">10.9.</span> <span class="toc-text">9、提高 webpack 的构建速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%B8%8E-webpack-%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.10.</span> <span class="toc-text">10、与 webpack 类似的工具还有哪些？区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rollup-%EF%BC%88%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E6%9B%B4%E7%AE%80%E6%B4%81%E3%80%81%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81-Tree-shaking%EF%BC%89"><span class="toc-number">10.10.1.</span> <span class="toc-text">Rollup （代码效率更简洁、效率更高，默认支持 Tree-shaking）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Js-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">Js 垃圾回收面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JS-%E9%87%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">1、JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Eventloop-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">Eventloop 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-x2F-Event-Loop"><span class="toc-number">12.1.</span> <span class="toc-text">1、什么是 事件循环&#x2F;Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-eventloop"><span class="toc-number">12.2.</span> <span class="toc-text">2、说一下事件循环 eventloop</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/undefined.html" title="前端初始样式与文件夹创建说明"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/two.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端初始样式与文件夹创建说明"/></a><div class="content"><a class="title" href="/undefined.html" title="前端初始样式与文件夹创建说明">前端初始样式与文件夹创建说明</a><time datetime="2023-04-06T13:20:00.000Z" title="发表于 2023-04-06 21:20:00">2023-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/43199.html" title="移动端rem自适应js写法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/three.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="移动端rem自适应js写法"/></a><div class="content"><a class="title" href="/43199.html" title="移动端rem自适应js写法">移动端rem自适应js写法</a><time datetime="2023-03-22T13:30:27.000Z" title="发表于 2023-03-22 21:30:27">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/14842.html" title="页面初始化css样式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/three.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="页面初始化css样式"/></a><div class="content"><a class="title" href="/14842.html" title="页面初始化css样式">页面初始化css样式</a><time datetime="2023-02-23T01:41:46.000Z" title="发表于 2023-02-23 09:41:46">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/48515.html" title="防抖与节流"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/eigth.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="防抖与节流"/></a><div class="content"><a class="title" href="/48515.html" title="防抖与节流">防抖与节流</a><time datetime="2022-09-30T08:00:44.000Z" title="发表于 2022-09-30 16:00:44">2022-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/30366.html" title="常用开发需要的软件跟插件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tent.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用开发需要的软件跟插件"/></a><div class="content"><a class="title" href="/30366.html" title="常用开发需要的软件跟插件">常用开发需要的软件跟插件</a><time datetime="2022-09-07T05:06:55.000Z" title="发表于 2022-09-07 13:06:55">2022-09-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/tent.webp')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ga.x</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>